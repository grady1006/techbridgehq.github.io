<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用 Object Recogniton Kitchen 的 Linemod 演算法辨識物體]]></title>
      <url>http://blog.techbridge.cc/2016/05/14/ros-object-recognition-kitchen/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這次要介紹的工具是 ROS 裡面專門用來作物體辨識的 <a href="http://wg-perception.github.io/object_recognition_core/" target="_blank" rel="external">Object Recognition Kitchen</a> (以下簡稱為 ORK )，這個工具比較像是一個框架，裡面包含了好幾種演算法(你可以根據自己的需求使用不同的演算法)，這篇文章要介紹的只是其中一種 – Linemod 。 Linemod 是一個辨識效果很不錯的 3D 物體辨識演算法(不過一個使用條件是物體須是剛體)，所以想藉此機會分享給大家，以後只要你想要，就可以直接拿這個工具來串自己的機器人應用。</p>
<h2 id="安裝-ORK-amp-Linemod"><a href="#安裝-ORK-amp-Linemod" class="headerlink" title="安裝 ORK &amp; Linemod"></a>安裝 ORK &amp; Linemod</h2><p>雖然 ORK 的開發者已經寫了一份滿不錯的<a href="http://wg-perception.github.io/object_recognition_core/install.html#install" target="_blank" rel="external">安裝 tutorial</a>，不過我覺得還是值得為他再寫一份自己的整理筆記，可以把過程中遇到的一些問題都整理下來供大家參考。</p>
<p>我目前跑起來的環境是 Ubuntu 14.04+ROS Indigo，首先來裝一些 ORK 需要用到的 package !</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DISTRO=indigo</span><br><span class="line">sudo apt-get install libopenni-dev ros-$&#123;DISTRO&#125;-catkin ros-$&#123;DISTRO&#125;-ecto* ros-$&#123;DISTRO&#125;-opencv-candidate ros-$&#123;DISTRO&#125;-moveit-msgs</span><br></pre></td></tr></table></figure>
<p>接下來就要安裝 ORK 啦，然後因為我比較喜歡 build from source，所以我會下面會放上一份複雜版的安裝方法，裡面會有比較多跟 error 奮鬥的過程，如果你比較喜歡直接玩應用，安裝什麼的懶得管，那看簡單版的安裝方式其實就可以了。</p>
<h3 id="超簡單版安裝方式"><a href="#超簡單版安裝方式" class="headerlink" title="超簡單版安裝方式"></a>超簡單版安裝方式</h3><p>超簡單版顧名思義就是超簡單，完全不要管我們會用到哪些 package，只要是 ORK 底下的 package，都裝下去，缺點就是會多浪費一些硬碟空間。只要用一行指令就搞定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-indigo-object-recognition-kitchen-*</span><br></pre></td></tr></table></figure>
<h3 id="稍微理解自己裝了什麼的安裝方式"><a href="#稍微理解自己裝了什麼的安裝方式" class="headerlink" title="稍微理解自己裝了什麼的安裝方式"></a>稍微理解自己裝了什麼的安裝方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-indigo-object-recognition-core ros-indigo-object-recognition-linemod ros-indigo-object-recognition-msgs ros-indigo-object-recognition-renderer ros-indigo-object-recognition-ros ros-indigo-object-recognition-ros-visualization</span><br></pre></td></tr></table></figure>
<h3 id="Build-From-Source版安裝方式"><a href="#Build-From-Source版安裝方式" class="headerlink" title="Build From Source版安裝方式"></a>Build From Source版安裝方式</h3><p>首先來先裝跟 ROS 銜接的 package，首先要先開啟 terminal，切到 catkin_workspace/src 底下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http://github.com/wg-perception/object_recognition_msgs</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_ros</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_ros_visualization</span><br></pre></td></tr></table></figure>
<p>然後因為今天的主角是 linemod，所以需要安裝相關 package</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http://github.com/wg-perception/object_recognition_core</span><br><span class="line">git clone http://github.com/wg-perception/linemod</span><br><span class="line">git clone http://github.com/wg-perception/ork_renderer</span><br><span class="line">cd ../ &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure>
<p>在 <code>catkin_make</code> 的過程中可能會碰到因 error 而中斷，會看到類似如下的訊息：</p>
<p><img src="/img/pojenlai/error_1.png" alt="catkin_make_error_1"></p>
<p>這時候不要怕，繼續給他 <code>catkin_make</code> 下去，你就會發現編譯進度會神奇地有進展：</p>
<p><img src="/img/pojenlai/error_2.png" alt="catkin_make_error_2"></p>
<p>不過我有碰到一個問題，再怎麼重新編譯都沒有用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In file included from /home/rosindigo/catkin_ws/src/ork_renderer/src/renderer3d.cpp:50:0:</span><br><span class="line">/home/rosindigo/catkin_ws/src/ork_renderer/src/renderer3d_impl_osmesa.h:39:23: fatal error: GL/osmesa.h: 沒有此一檔案或目錄</span><br><span class="line"> #include &lt;GL/osmesa.h&gt;</span><br><span class="line"> ^</span><br><span class="line"> compilation terminated.</span><br><span class="line"> make[2]: *** [ork_renderer/src/CMakeFiles/object_recognition_renderer_3d.dir/renderer3d.cpp.o] Error 1</span><br><span class="line"> make[1]: *** [ork_renderer/src/CMakeFiles/object_recognition_renderer_3d.dir/all] Error 2</span><br><span class="line"> make: *** [all] Error 2</span><br><span class="line"> Invoking &quot;make -j8 -l8&quot; failed</span><br></pre></td></tr></table></figure>
<p>因為是少了 GL/osmesa.h，所以需要額外下一個指令 <code>sudo apt-get install libosmesa6-dev</code> 來安裝。</p>
<p>裝到這邊還會有一個問題，就是雖然編譯都已經過了，但 <code>roscd object_recognition_core</code> 時都會出現無法找到此 package 的 error，由於這會對後續要執行演算法時造成問題，所以還是要來處理一下。</p>
<p>我們先重新理一下思路，理論上，編譯過之後就會被加入到 <code>roscd</code> 可以找到的 path 中，但是 <code>roscd</code> 顯然就表示沒有被加進  ROS_PACKAGE_PATH 中，google 了一下發現到有人也遇過類似的問題，解法也確實就是把我們 git clone 下來的那些 package 加入到 ROS_PACKAGE_PATH 中，這樣的話問題就簡單啦!</p>
<p> 先 <code>vim ~/.bashrc</code> 一下，然後在最下面補上一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ROS_PACKAGE_PATH=&quot;$ROS_PACKAGE_PATH:/home/rosindigo/catkin_ws/src&quot;</span><br></pre></td></tr></table></figure>
<p>補完的結果看起來就像:</p>
<p><img src="/img/pojenlai/bashrc.png" alt="bachrc"></p>
<h2 id="接上並從-RGB-D-Sensor-收資料"><a href="#接上並從-RGB-D-Sensor-收資料" class="headerlink" title="接上並從 RGB-D Sensor 收資料"></a>接上並從 RGB-D Sensor 收資料</h2><p>接下來我們要先處理感測器這塊，畢竟如果沒有感測器，那就根本不用辨識物體的對吧。原本官方教學上是建議用 <code>roslaunch openni2_launch openni2.launch</code>，但因為我是用 Kinect 1，要用 <code>roslaunch openni_launch openni.launch</code>。</p>
<p>跑起來之後應該就可以在 Rviz 看到以下的畫面:</p>
<p><img src="/img/pojenlai/kinect_rviz.png" alt="kinect_rviz"></p>
<h2 id="安裝物體辨識資料庫-amp-加入-model"><a href="#安裝物體辨識資料庫-amp-加入-model" class="headerlink" title="安裝物體辨識資料庫 &amp; 加入 model"></a>安裝物體辨識資料庫 &amp; 加入 model</h2><p>ORK 是一套以 template matching 方法為主的辨識工具，也就是說，他會把感測器看到的物體跟資料庫中的物體比對，夠相似的就算是辨識成功，所以我們接著要來處理資料庫這一塊。首先要安裝 CouchDB 這個工具 (用 <code>sudo apt-get install couchdb</code> )。</p>
<p>接下來檢查一下是否有安裝成功 (用 <code>curl -X GET http://localhost:5984</code> )。如果成功，應該會看到類似下面的畫面：</p>
<p><img src="/img/pojenlai/couchdb.png" alt="curl_couchdb"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun object_recognition_core object_add.py -n &quot;coke &quot; -d &quot;A universal can of coke&quot; --commit</span><br></pre></td></tr></table></figure>
<p>執行上面這個指令之後，你可以去 <a href="http://localhost:5984/_utils/database.html?object_recognition/_design/objects/_view/by_object_name" target="_blank" rel="external">http://localhost:5984/_utils/database.html?object_recognition/_design/objects/_view/by_object_name</a> 看看自己的資料庫裡是否已經新增了這個物體：</p>
<p><img src="/img/pojenlai/object_id.png" alt="obj_id"></p>
<p>接下來就是要指定這個物體的 3D 模型是什麼，這邊就需要先下載個 package 並編譯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg-perception/ork_tutorials</span><br><span class="line">cd .. &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure>
<p>ork_tutorials裡面有一個 coke.stl 檔，他就是一個可樂罐的 3D 模型，足夠讓我們先用來辨識。注意下面這個指令中有一串看起來像亂碼的東西，但那其實是物體的 id ，這就要從你自己的資料庫裡去看了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun object_recognition_core mesh_add.py 0be612246c9b0a00baaa4adefb0009eb /home/rosindigo/catkin_ws/src/ork_tutorials/data/coke.stl --commit</span><br></pre></td></tr></table></figure>
<h3 id="執行-Linemod-演算法-Training-amp-Detection"><a href="#執行-Linemod-演算法-Training-amp-Detection" class="headerlink" title="執行 Linemod 演算法 (Training &amp; Detection)"></a>執行 Linemod 演算法 (Training &amp; Detection)</h3><p>好了!終於要進入正題了，這一塊一樣有 <a href="http://wg-perception.github.io/ork_tutorials/tutorial03/tutorial.html" target="_blank" rel="external">官方tutorial</a> 可以參考，我們先從 Training 開始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun object_recognition_core training -c `rospack find object_recognition_linemod`/conf/training.ork</span><br></pre></td></tr></table></figure>
<p>這個 training 指令會利用資料庫裡的 3D 模型建立辨識時所需要的 template，如果執行成功，你會看到如下的訊息：</p>
<p><img src="/img/pojenlai/training.png" alt="train"></p>
<p>如果已經訓練完畢，下一步就是用他來辨識物體啦。</p>
<p>可惜筆者的 Kinect 突然壞掉了，沒有辦法直接 demo 出來，不過這邊的指令也不會很複雜。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">roslaunch openni_launch openni.launch</span><br><span class="line">rosrun dynamic_reconfigure dynparam set /camera/driver depth_registration True</span><br><span class="line">rosrun dynamic_reconfigure dynparam set /camera/driver image_mode 2 </span><br><span class="line">rosrun dynamic_reconfigure dynparam set /camera/driver depth_mode 2</span><br><span class="line">rosrun topic_tools relay /camera/depth_registered/image_raw /camera/depth_registered/image</span><br><span class="line">rosrun object_recognition_core detection -c  `rospack find object_recognition_linemod`/conf/detection.ros.ork</span><br></pre></td></tr></table></figure>
<p>接下來就可以用 Rviz 來看辨識結果啦！</p>
<p><img src="/img/pojenlai/rviz_result.png" alt="rviz_result"></p>
<h2 id="演算法簡介"><a href="#演算法簡介" class="headerlink" title="演算法簡介"></a>演算法簡介</h2><p>既然 Linemod 是一個這麼強大的演算法，試著去稍微了解一下演算法也是很合理的，原始的<a href="http://campar.in.tum.de/pub/hinterstoisser2011linemod/hinterstoisser2011linemod.pdf" target="_blank" rel="external">論文</a>在這邊 (2011 ICCV 的 oral 論文)，以下的圖片也是出自這篇論文。</p>
<p>首先來看一下這篇論文的辨識結果：</p>
<p><img src="/img/pojenlai/paper_1.jpg" alt="result"></p>
<p>這個演算法的核心概念就是整合多種不同的 modalities，把 modality 想成物體的不同特徵可能比較好懂，例如下圖中就有兩種 modalities – gradient 跟 surface normal，而因為這兩種特徵所表達的特性不一樣，所以可以互補，進而達到更好的辨識效果。</p>
<p><img src="/img/pojenlai/paper_2.jpg" alt="concept"></p>
<p>所以說，Linemod 需要先有已知的物體模型，然後先取得這個物體各種 modlaities 的template，這樣在辨識的時候就可以拿 template 來比對。</p>
<p>不過這概念在電腦視覺領域中並不特別，因為同時使用不同特徵來加強物體辨識的效果是很直覺的，也有很多不同的方法可以做到這件事情，所以這篇論文還提出了一個方法來增進 similarity measurement 的效率 ( similarity measurement 的意思是 measure 儲存的 template 跟現在看到的影像資料有多接近)。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這篇文章很簡略地介紹了 ORK 的安裝、基本的使用方式(使用 Linemod )、還有演算法簡介，有興趣的讀者可以自己動手玩玩看 (如果沒有實體的 RGB-D sensor，你也可以試著用 Gazebo 裡面的 Kinect 來模擬)!</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://wg-perception.github.io/ork_tutorials/tutorial02/tutorial.html" target="_blank" rel="external">使用 ORK 的 tabletop 演算法</a></li>
<li><a href="http://wg-perception.github.io/ork_tutorials/tutorial01/tutorial.html" target="_blank" rel="external">建立自己的 ORK 模型</a></li>
<li><a href="https://vimeo.com/66584131" target="_blank" rel="external">ORK 開發者介紹演講</a></li>
<li><a href="https://github.com/Itseez/opencv_contrib/blob/master/modules/rgbd/src/linemod.cpp" target="_blank" rel="external">Linemod的OpenCV實作</a></li>
</ol>
<p>關於作者：<br><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[從 Flux 與 MVC 的差異來簡介 Flux]]></title>
      <url>http://blog.techbridge.cc/2016/04/29/introduce-flux-from-flux-and-mvc/</url>
      <content type="html"><![CDATA[<p>今天這篇主要是想藉由<code>Flux</code>的介紹，進而探討<code>Flux</code>與<code>MVC</code>的差異，到底<code>Flux</code>做對了什麼，而<code>MVC</code>又犯了什麼錯呢？</p>
<p>首先我們回顧一下<a href="https://www.youtube.com/watch?v=nYkdrAPrdcw" target="_blank" rel="external">2014 F8大會 - Hacker Way</a>的影片<br><a href="http://www.youtube.com/watch?feature=player_embedded&v=nYkdrAPrdcw" target="_blank"><br><img src="http://img.youtube.com/vi/nYkdrAPrdcw/0.jpg" alt="2014 F8大會 - Hacker Way" width="240" height="180" border="10"><br></a><br>其中 Jing Chen 用了兩張圖來做對比，說明MVC的觀念在複雜的Application下難以維護。</p>
<p><img src="/img/arvinh/flux-react-mvc.png" alt="facebook MVC" title="facebook MVC"></p>
<p>經驗豐富一點的Developer看到這張圖的第一個念頭應該會是：”What the fxxx… 誰家的MVC長這樣啊？” 沒錯！Jing Chen 事後在Reddit上也有回覆，主要是想利用這張圖把MVC在大型架構下，資料 與 視圖 之間的 <code>bi-directional data flow</code>，容易造成<code>cascading effects</code>的問題凸顯出來。</p>
<p>為了解決她說的這個問題，Facebook 提出了<code>Flux</code></p>
<h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>Flux是一種讓你很容易做到 one-way data flow 的<span style="color:red">概念</span>，讓你View中的每個component的state都能夠<code>predictable</code>。</p>
<p><img src="/img/arvinh/flux-react.png" alt="facebook Flux" title="facebook Flux"></p>
<h3 id="Views-Dispatch-Actions"><a href="#Views-Dispatch-Actions" class="headerlink" title="Views Dispatch Actions"></a>Views Dispatch Actions</h3><p><code>Dispatcher</code>是一個重要的event system，用來broadcast events以及registers callbacks，一般來說Dispatcher是唯一且global的，可以參考Facebook的<a href="https://github.com/facebook/flux/blob/master/src/Dispatcher.js" target="_blank" rel="external">Dispatcher Library</a>（題外話，有許多一些Flux的framework並非這樣使用）</p>
<p>簡單來看個Dispatcher的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假設你initiate一個dispatcher</span></span><br><span class="line"><span class="keyword">var</span> AppDispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line"></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//在你的 component.jsx 中，可能會有這樣的程式</span></span><br><span class="line">createNewItem: <span class="function"><span class="keyword">function</span>(<span class="params"> evt </span>) </span>&#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    actionName: <span class="string">'newPhoto'</span>,</span><br><span class="line">    newItem: &#123; name: <span class="string">'Happy Holiday'</span> &#125; <span class="comment">// example data</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;button onClick=&#123; this.createNewPhoto &#125;&gt;New Photo&lt;/button&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當每次的<code>onClick</code>發生後，<code>View</code>就會透過<code>Dispatcher</code>dispatch出一個<code>Action</code>，該Action可以包含一個<code>payload</code>，說明<code>你想做什麼事情</code>以及<code>你需要操作什麼資料</code>。</p>
<h3 id="Store-Responds-to-Dispatched-Actions"><a href="#Store-Responds-to-Dispatched-Actions" class="headerlink" title="Store Responds to Dispatched Actions"></a>Store Responds to Dispatched Actions</h3><p>Store在Flux的架構內，通常是Singleton(一樣，有些framework並非這樣做，尤其是想達成isomorphic時，可以參考<a href="http://fluxible.io/" target="_blank" rel="external">Yahoo Fluxible</a>)</p>
<p>在Flux的概念中，Store基本上是你唯一可以<strong>操作資料</strong>與<strong>儲存資料</strong>的地方。去除操作資料的部分，聽起來有點像MVC中的Model? 更明確一點來說，<strong>Store contains Models</strong></p>
<p>舉例來說，當你需要存放一些照片以及其Meta data時，你會Create一個PhotoStore來存放Photo model與Meta model。你會依照資料的<code>Domain</code>來切割你的Store。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PhotoStore = &#123;</span><br><span class="line">  <span class="comment">// collection of model data</span></span><br><span class="line">  photos: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>( payload.actionName ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'newPhoto'</span>:</span><br><span class="line">      PhotoStore.photos.push(payload.newPhoto);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Store</code>會向<code>Dispatcher</code>註冊<code>Callback</code>，依照各種action的類別執行相對應的資料操作。</p>
<h3 id="Store-Emits-“Change”-Event-to-View"><a href="#Store-Emits-“Change”-Event-to-View" class="headerlink" title="Store Emits “Change” Event to View"></a>Store Emits “Change” Event to View</h3><p>當你的Store資料做完更新後，要告訴前端頁面去刷新視圖，通常可以在Store註冊的Callback中執行以下動作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>( payload.actionName ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'newPhoto'</span>:</span><br><span class="line">      PhotoStore.photos.push(payload.newPhoto);</span><br><span class="line">      <span class="comment">// trigger "Change" event 通知View去做更新</span></span><br><span class="line">      PhotoStore.trigger(<span class="string">'change'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>接著，如果你是搭配React當作你的View的話，可能會在<code>componentDidMount</code>時，binding一個Store listener</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    PhotoStore.bind( <span class="string">'change'</span>, <span class="keyword">this</span>.photoChange );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在listener中重新fetch store資料，並且setState來re-render Component</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">photoChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> newPhotoData = PhotoStore.getPhoto();</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      photos: newPhotoData</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的Component的render function大概會像這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> photosComponet = <span class="keyword">this</span>.state.photos.map(<span class="function"><span class="keyword">function</span>(<span class="params">photo, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li key=&#123;'photo'+i&#125;&gt;</span><br><span class="line">        &#123;photo&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    );          </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;photosComponet&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完簡單的Flux介紹後，讓我們再複習一次Flux的流程圖</p>
<p><img src="/img/arvinh/flux-react.png" alt="facebook Flux" title="facebook Flux"></p>
<p>相信在業界打滾多年的Developer們應該早有疑惑了，Flux的那張圖，跟最原始的MVC圖不是很像嗎？！</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/500px-MVC-Process.svg.png" alt="MVC definition in wikipedia" title="MVC definition in wikipedia"></p>
<p>User操作View所產生的任何event，都會經由Controller來修改與更動相關的Model，而Model再告知View是否需要做更動，聽起來也是蠻<code>one-way direction</code>的呀。</p>
<p>事實上，MVC 跟 Flux 都只是一個概念，因此有各種不同的實作，加上MVC在<code>資料流</code>的處理上，並不像Flux一般有較為明確的定義，多數時候Model的更動與View的刷新可能會透過Controller來管理，讓Model單純存放data。</p>
<p>如此一來，假若今天View的操作更動了Model，而Model的變化又刷新了View，在系統龐大的時候，一來一往，就會讓你的資料與頁面狀態變得非常複雜，要追蹤某個頁面的變動到底是誰觸發的，或是哪個資料改變了，你必須從Controller去慢慢trace。而若是遵照Flux的流程，任何View的update都只要去追蹤其State的來源Store即可，有一個明確的flow可以遵循，並且每個View所需要監聽的資料來源，可以依照Store來區分，這之間的資料流不會互相干擾。<br>另外一個Flux的好處是，能夠更輕鬆的做出更Unit的Unit test。這是你在複雜的Controller中難以達成的。</p>
<p>當然，你可能會想：“這是你MVC用得不好“。 </p>
<p>我覺得這樣講也沒什麼不對，如果你MVC用得很熟很順手，的確單單是Flux這個東西對你的誘因可能不高，但當一間明星公司大力Promote，對於基本概念的定義又夠清楚單純時，還是值得你試試。更別說Flux搭配上React的宣告式寫法，用起來更是如魚得水。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>Flux做的是：</p>
<ol>
<li>改善<code>資料狀態</code>與<code>視圖狀態</code>的 Data Flow</li>
<li>讓頁面的狀態<code>Predictable</code></li>
<li>資料流不會互相污染</li>
<li>讓你的測試更加容易</li>
</ol>
<p>而MVC在關注點分離上的貢獻不可小覷，重視在將資料(Model)、視圖(View)、邏輯(Controller)拆開，各自負責各自的工作。</p>
<p>因此並非是MVC不好、不對，所以我們應該採用Flux；Flux是在MVC建立的基礎下，定義出一個清楚的<code>one-way direction</code>資料流，並且透過<code>Action</code>、<code>Dispatcher</code>與<code>Store</code>來幫助整個概念的實現。</p>
<h3 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h3><p>如同前面所提，Flux的實作有很多種，這邊介紹的只是最基本的流程，很多Framework在設計自己的Dispatcher, Action 與 Store時，會有不同的方式，或許可以從這邊的比較下去看看</p>
<ul>
<li><a href="https://github.com/voronianski/flux-comparison" target="_blank" rel="external">Flux Comparison</a></li>
<li><a href="https://github.com/enaqx/awesome-react" target="_blank" rel="external">Awesome React</a></li>
</ul>
<p>參考資料</p>
<ul>
<li><a href="http://blog.andrewray.me/flux-for-stupid-people/" target="_blank" rel="external">Flux for stupid people</a></li>
<li><a href="http://www.infoq.com/news/2014/05/facebook-mvc-flux" target="_blank" rel="external">Facebook: MVC Does Not Scale, Use Flux Instead</a></li>
</ul>
<p>關於作者：<br><a href="http://blog.arvinh.info/about/" target="_blank" rel="external">@arvinh</a> 前端攻城獅，熱愛數據分析和資訊視覺化</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用 Node.js 快速打造 RESTful API]]></title>
      <url>http://blog.techbridge.cc/2016/04/23/fast-restful-nodejs-api-backend/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現今有些網站採用了 Single Page Application 的方案，後端只負責提供 API 讓前端抓取資料，達成完全的前後端分離。前端的選擇有很多種，你可以用 <code>Angular</code>，可以用 <code>Ember.js</code>，也可以用 <code>React + Redux</code>。至於後端的 API，必須符合固定格式，才能讓前端的人員比較好抓取。而這個「固定格式」，最常見的就是我們今天的重點：<code>RESTful</code>。</p>
<h2 id="什麼是-RESTful？"><a href="#什麼是-RESTful？" class="headerlink" title="什麼是 RESTful？"></a>什麼是 RESTful？</h2><p>與起從硬生生的文字解釋下手，不如先從實際範例著手。假設現在你要寫一個部落格網站的後端 API，十個人可能會有十種寫法；例如說「抓取所有文章」這個功能：</p>
<ol>
<li>/api/blog/getList</li>
<li>/api/blog/getAllArticle</li>
<li>/api/blog/article/getAll</li>
<li>/api/blog/fetchAll</li>
<li>/api/blog/all</li>
</ol>
<p>但如果是採取 <code>RESTful</code> 的方案，就會符合一定的格式：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Method</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有文章</td>
<td>GET</td>
<td>/api/posts</td>
</tr>
<tr>
<td>單一文章</td>
<td>GET</td>
<td>/api/posts/:id</td>
</tr>
<tr>
<td>新增文章</td>
<td>POST</td>
<td>/api/posts</td>
</tr>
<tr>
<td>刪除文章</td>
<td>DELETE</td>
<td>/api/posts/:id</td>
</tr>
<tr>
<td>修改文章</td>
<td>PUT/PATCH</td>
<td>/api/posts/:id</td>
</tr>
</tbody>
</table>
<p>在這個例子裡，文章（posts）是一個 <code>Resource</code>，你可以透過 HTTP 提供的幾種方法搭配不同的 URL 存取這個 <code>Resource</code>。</p>
<p>如果你對 <code>RESTful</code> 很有興趣，這邊是一些值得參考的文章：</p>
<ol>
<li><a href="https://ihower.tw/blog/archives/1542" target="_blank" rel="external">什麼是REST跟RESTful?</a></li>
<li><a href="http://blog.toright.com/posts/725" target="_blank" rel="external">淺談 REST 軟體架構風格</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">理解RESTful架構</a></li>
</ol>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM 的全稱是：Object Relational Mapping<br>如果以資料庫來說的話，就是把你的資料庫對應到程式裡的物件。舉上面的部落格的例子，你的資料庫 table 可能是這樣：</p>
<table>
<thead>
<tr>
<th>欄位</th>
<th>類型</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>int</td>
<td>id</td>
</tr>
<tr>
<td>title</td>
<td>text</td>
<td>標題</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>內文</td>
</tr>
<tr>
<td>created_at</td>
<td>timestamp</td>
<td>建立時間</td>
</tr>
</tbody>
</table>
<p>對應到 Node.js 裡面的物件，你可以這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立文章</span></span><br><span class="line">Post.create(&#123;</span><br><span class="line">  title: <span class="string">'Hello Excel'</span>,</span><br><span class="line">  content: <span class="string">'測試'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刪除 id 為 1 的文章</span></span><br><span class="line">Post.find(<span class="number">1</span>).delete();</span><br></pre></td></tr></table></figure>
<p>也就是說，你今天根本不用管背後的資料庫用的是哪一種，也不用管 table 的名稱到底是什麼，你只要對你知道的這個 <code>Post</code> 物件做操作即可。</p>
<p><a href="http://docs.sequelizejs.com/en/latest/" target="_blank" rel="external">Sequelize</a>是一套很好用的 ORM Library，只要先定義好一份<code>schema</code>，就可以幫你把物件跟資料庫關連起來。</p>
<h2 id="為什麼突然提到-ORM？"><a href="#為什麼突然提到-ORM？" class="headerlink" title="為什麼突然提到 ORM？"></a>為什麼突然提到 ORM？</h2><p>有些讀者可能已經想到，其實 RESTful API 跟 ORM 之間，是有某種程度的關聯的。怎麼說呢？  </p>
<p>假設我今天要寫一個留言板的後端 API，而且我又同時採用 RESTful 跟 ORM，我的程式就會長這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抓取所有留言</span></span><br><span class="line"><span class="comment">// GET /api/messages</span></span><br><span class="line">Message.findAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抓取單一留言</span></span><br><span class="line"><span class="comment">// GET /api/messages/:id</span></span><br><span class="line">Message.find(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增留言</span></span><br><span class="line"><span class="comment">// POST /api/messages</span></span><br><span class="line">Messages.create(&#123;</span><br><span class="line">  content: content</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刪除留言</span></span><br><span class="line"><span class="comment">// DELETE /api/messages/:id</span></span><br><span class="line">Messages.find(id).delete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改留言</span></span><br><span class="line"><span class="comment">// PUT /api/messages/:id</span></span><br><span class="line">Messages.find(id).update(&#123;</span><br><span class="line">  content: new_content</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那如果我今天是寫一個部落格的後端 API 呢？<br>把上面的 messages 全部換成 posts，搞定！<br>從以上例子可以看出，其實這兩樣東西是很適合搭配在一起的，因為兩個都能夠符合差不多的規則。</p>
<h2 id="兩個願望一次滿足，epilogue"><a href="#兩個願望一次滿足，epilogue" class="headerlink" title="兩個願望一次滿足，epilogue"></a>兩個願望一次滿足，epilogue</h2><p><a href="https://github.com/dchester/epilogue" target="_blank" rel="external">epilogue</a> 是一套 Node.js 的 Library，它結合了 <code>Sequelize</code> 跟 <code>Express</code>，主要目的就是讓我們能快速打造出 RESTful 的 API。</p>
<p>讓我們直接來看看官網的範例：</p>
<p>首先，你要先定義好的資料庫，跟你的 schema</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> database = <span class="keyword">new</span> Sequelize(<span class="string">'database'</span>, <span class="string">'root'</span>, <span class="string">'password'</span>);</span><br><span class="line"><span class="keyword">var</span> User = database.define(<span class="string">'User'</span>, &#123;</span><br><span class="line">  username: Sequelize.STRING,</span><br><span class="line">  birthday: Sequelize.DATE</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再來，初始化 express 跟 epilogue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">    bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: <span class="literal">false</span> &#125;));</span><br><span class="line">server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">epilogue.initialize(&#123;</span><br><span class="line">	app: app,</span><br><span class="line">	sequelize: database</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最後，靠 epilogue 把 url 跟資料庫關連起來，你要提供它你想要的 endpoint 跟要關連的 model</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userResource = epilogue.resource(&#123;</span><br><span class="line">  model: User,</span><br><span class="line">  endpoints: [<span class="string">'/users'</span>, <span class="string">'/users/:id'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>就是這樣簡單三個步驟，你就有了一個 RESTful API！是不是很簡單呢？</p>
<h2 id="還不只這樣"><a href="#還不只這樣" class="headerlink" title="還不只這樣"></a>還不只這樣</h2><p>在實際的開發過程中，其實往往沒有那麼順利，例如說你的回傳格式可能跟資料庫的格式不一樣，或是你的某些 API 需要經過認證才能呼叫。沒關係，epilogue 都幫你想好了。</p>
<p>epilogue 提供了七種行為的 hook，包括 start, auth, fetch, data, write, send, complete，再搭配上 before, action, after 三種，你可以在任何一個階段做你想做的事情。</p>
<p>例如說你想在傳回結果之前做一點小小的變更，就是<code>userResource.list.send.before</code>，或是你可能想對某個 API 做驗證，那就是<code>userResource.delete.auth</code>。</p>
<p>這邊提供兩個官網的完整範例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止刪除 user</span></span><br><span class="line">userResource.delete.auth(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ForbiddenError(<span class="string">"can't delete a user"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先看有沒有 cache，有的話直接返回 cache 的內容</span></span><br><span class="line">userResource.list.fetch.before(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = cache.get(context.criteria);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// keep a reference to the instance and skip the fetch</span></span><br><span class="line">    context.instance = instance;</span><br><span class="line">    <span class="keyword">return</span> context.skip;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// cache miss; we continue on</span></span><br><span class="line">    <span class="keyword">return</span> context.continue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>若是你的後端 API 沒有很複雜，都是基本的 CRUD 的話，那 epilogue 絕對是很適合你的一套框架，只要你把資料庫的 schema 開出來，程式碼複製貼上一下就能夠完成一個 API。若是讀者之後有相關的需求，不妨試試看吧！</p>
<p>關於作者：<br><a href="http://huli.logdown.com/" target="_blank" rel="external">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一看就懂的 JSX 簡明入門教學指南]]></title>
      <url>http://blog.techbridge.cc/2016/04/21/react-jsx-introduction/</url>
      <content type="html"><![CDATA[<p><img src="/img/kdchang/reactjs.png" alt="一看就懂的 JSX 簡明入門教學指南"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根據 <a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> 官方定義，React 是一個構建使用者介面的 JavaScritp Library。以 MVC 模式來說，ReactJS 主要是負責 View 的部份。過去一段時間，我們被灌輸了許多前端分離的觀念，在前端三兄弟中（或三姊妹、三劍客）：HTML 掌管內容結構、CSS 負責外觀樣式，JavaScript 主管邏輯互動，千萬不要混在一塊。然而，在 React 世界裡，所有事物都是 以 Component 為基礎，將同一個 Compoent 相關的程式和資源都放在一起，而在撰寫 React Component 時我們通常會使用 <a href="https://facebook.github.io/jsx/" target="_blank" rel="external">JSX</a> 的方式來提升程式撰寫效率。事實上，JSX 並非一種全新的語言，而是一種語法糖（<a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="external">Syntatic Sugar</a>），一種語法類似 <a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="external">XML</a> 的 ECMAScript 語法擴充。在 JSX 中 HTML 和組建這些元素標籤的程式碼有緊密的關係。因此你可能要熟悉一下以 Component 為單位的思考方式（本文主要使用 ES6 語法）。</p>
<p>此外，React 和 JSX 的思維在於善用 JavaScript 的強大能力，放棄蹩腳的模版語言，這和 <a href="https://angularjs.org/" target="_blank" rel="external">Angular</a> 強化 HTML 的理念也有所不同。當然 JSX 並非強制使用，你也可以選擇不用，因為最終 JSX 的內容會轉化成 JavaScript（瀏覽器只看的懂 JavaScript）。不過等你閱讀完接下來的內容，你或許會開始發現 JSX 的好，認真考慮使用 JSX 的語法。</p>
<h2 id="一、使用-JSX-的好處"><a href="#一、使用-JSX-的好處" class="headerlink" title="一、使用 JSX 的好處"></a>一、使用 JSX 的好處</h2><h3 id="1-提供更加語意化且易懂的標籤"><a href="#1-提供更加語意化且易懂的標籤" class="headerlink" title="1. 提供更加語意化且易懂的標籤"></a>1. 提供更加語意化且易懂的標籤</h3><p>由於 JSX 類似 XML 的語法，讓一些非開發人員也更容易看懂，且能精確定義包含屬性的樹狀結構。一般來說我們想做一個回饋表單，使用 HTML 寫法通常會長這樣：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"messageBox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">teextarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 JSX，就像 XML 語法結構一樣可以自行定義標籤且有開始和關閉，容易理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MessageBox /&gt;</span><br></pre></td></tr></table></figure>
<p>React 思路認為使用 Component 比起模版（Template）和顯示邏輯（Display Logic）更能實現關注點分離的概念，而搭配 JSX 可以實現聲明式 <code>Declarative</code>（注重 what to），而非命令式  <code>Imperative</code>（注重 how to）的程式撰寫方式：</p>
<p><img src="/img/kdchang/fb_like.jpg" alt="Facebook 上面按讚功能"></p>
<p>以 Facebook 上面按讚功能來說，若是命令式 <code>Imperative</code> 寫法大約會是長這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(userLikes()) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!hasBlueLike()) &#123;</span><br><span class="line">    removeGrayLike();</span><br><span class="line">    addBlueLike();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(hasBlueLike()) &#123;</span><br><span class="line">    removeBlueLike();</span><br><span class="line">    addGrayLike();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若是聲明式 <code>Declarative</code> 則是會長這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.state.liked) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">BlueLike</span> /&gt;</span>);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return (<span class="tag">&lt;<span class="name">GrayLike</span> /&gt;</span>);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>看完上述說明是不是感覺 <code>React</code> 結合 <code>JSX</code> 的寫法更易讀易懂？事實上，當 Component 組成越來越複雜時，若使用 JSX 將可以讓整個結構更加直觀，可讀性較高。</p>
<h3 id="2-更加簡潔"><a href="#2-更加簡潔" class="headerlink" title="2. 更加簡潔"></a>2. 更加簡潔</h3><p>雖然最終 JSX 會轉換成 JavaScript，但使用 JSX 可以讓程式看起來更加簡潔，以下為使用 JSX 和不使用 JSX 的範例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://facebook.github.io/react/"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不使用 JSX 的情況（記得我們說過 JSX 是選用的）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement(元件/HTML標籤, 元件屬性，以物件表示, 子元件)</span></span><br><span class="line">React.createElement(<span class="string">'a'</span>, &#123;href: <span class="string">'https://facebook.github.io/react/'</span>&#125;, <span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-結合原生-JavaScript-語法"><a href="#3-結合原生-JavaScript-語法" class="headerlink" title="3. 結合原生 JavaScript 語法"></a>3. 結合原生 JavaScript 語法</h3><p>JSX 並非一種全新的語言，而是一種語法糖（Syntatic Sugar），一種語法類似 XML 的 ECMAScript 語法擴充，所以並沒有改變 JavaScript 語意。透過結合 JavaScript ，可以釋放 JavaScript 語言本身能力。下面例子就是運用 <code>map</code> 方法和 <code>Arrow function</code>，輕易把 <code>result</code> 值迭代出來，產生無序清單（ul）的內容，不用再使用蹩腳的模版語言：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 為常數</span></span><br><span class="line"><span class="keyword">const</span> lists = [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Node'</span>, <span class="string">'Python'</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Compoent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      &#123;lists.map((result) =&gt; &#123;</span><br><span class="line">        return (<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>);</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、JSX-用法摘要"><a href="#二、JSX-用法摘要" class="headerlink" title="二、JSX 用法摘要"></a>二、JSX 用法摘要</h2><h3 id="1-環境設定與使用方式"><a href="#1-環境設定與使用方式" class="headerlink" title="1. 環境設定與使用方式"></a>1. 環境設定與使用方式</h3><p>初步了解為何要使用 JSX 後，我們來聊聊 JSX 的用法。一般而言 JSX 通常有兩種使用方式：</p>
<ol>
<li>使用 <a href="http://browserify.org/" target="_blank" rel="external">browserify</a> 或 <a href="https://webpack.github.io/" target="_blank" rel="external">webpack</a> 等 <a href="https://en.wikipedia.org/wiki/CommonJS" target="_blank" rel="external">CommonJS</a> bundler 並整合 <a href="https://babeljs.io/" target="_blank" rel="external">babel</a> 預處理</li>
<li>於瀏覽器端做解析</li>
</ol>
<p>在這邊簡單起見，我們先使用第二種方式，先讓大家專注熟悉 JSX 語法使用，等到後面章節再教大家使用 bundler 的方式去做解析（可以試著把下面的原始碼貼到 <a href="http://jsbin.com/" target="_blank" rel="external">JSbin</a> 的 HTML 看結果）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 請先於 index.html 中引入 react.js, react-dom.js 和 babel-core 的 browser.min.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react-dom.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="javascript"></span><br><span class="line">      <span class="comment">// 程式碼寫在這邊！</span></span><br><span class="line">      ReactDOM.render(</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">      );</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般載入 JSX 方式有：</p>
<ul>
<li>內嵌</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="javascript"></span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">  );</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>從外部引入</li>
</ul>
<p><code>&lt;script type=&quot;text/jsx&quot; src=&quot;main.jsx&quot;&gt;&lt;/script&gt;</code> </p>
<h3 id="2-標籤用法"><a href="#2-標籤用法" class="headerlink" title="2. 標籤用法"></a>2. 標籤用法</h3><p>JSX 標籤非常類似 XML ，可以直接書寫。一般 Component 命名首字大寫，HTML Tags 小寫。以下是一個建立 Component 的 class：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Compoent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MessageList</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-轉換成-JavaScript"><a href="#3-轉換成-JavaScript" class="headerlink" title="3. 轉換成 JavaScript"></a>3. 轉換成 JavaScript</h3><p>JSX 最終會轉換成瀏覽器可以讀取的 JavaScript，以下為其規則：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  string/ReactClass, <span class="comment">// 表示 HTML 元素或是 React Component</span></span><br><span class="line">  [object props], <span class="comment">// 屬性值，用物件表示</span></span><br><span class="line">  [children] <span class="comment">// 接下來參數皆為元素子元素</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>解析前（特別注意在 JSX 中使用 JavaScript 表達式時使用 {} 括起，如下方範例的 <code>text</code>，裡面對應的是變數。若需希望放置一般文字，請加上 <code>&#39;&#39;</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'Hello React'</span>;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;h1&gt;&#123;<span class="string">'text'</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure>
<p>解析完後：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'Hello React'</span>;</span><br><span class="line">React.createElement(<span class="string">"h1"</span>, <span class="literal">null</span>, <span class="string">"Hello React!"</span>);</span><br></pre></td></tr></table></figure>
<p>另外要特別要注意的是由於 JSX 最終會轉成 JavaScript 且每一個 JSX 節點都對應到一個 JavaScript 函數，所以在 Component 的 <code>render</code> 方法中只能回傳一個根節點（Root Nodes）。例如：若有多個 <code>&lt;div&gt;</code> 要 <code>render</code> 請在外面包一個 Component 或 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 元素。</p>
<h3 id="4-註解"><a href="#4-註解" class="headerlink" title="4. 註解"></a>4. 註解</h3><p>由於 JSX 最終會編譯成 JavaScript，註解也一樣使用 <code>//</code> 和 <code>/**/</code> 當做註解方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 單行註解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">  多行註解</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> content = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">List</span>&gt;</span></span><br><span class="line">      &#123;/* 若是在子元件註解要加 &#123;&#125;  */&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">Item</span></span><br><span class="line">        /* 多行</span><br><span class="line">           註解</span><br><span class="line">           喔 */</span><br><span class="line">        <span class="attr">name</span>=<span class="string">&#123;window.isLoggedIn</span> ? <span class="attr">window.name</span> <span class="attr">:</span> ''&#125; // 單行註解</span><br><span class="line">      /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">List</span>&gt;</span></span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<h3 id="5-屬性"><a href="#5-屬性" class="headerlink" title="5. 屬性"></a>5. 屬性</h3><p>在 HTML 中，我們可以透過標籤上的屬性來改變標籤外觀樣式，在 JSX 中也可以，但要注意 <code>class</code> 和 <code>for</code> 由於為 JavaScript 保留關鍵字用法，因此在 JSX 中使用 <code>className</code> 和 <code>htmlFor</code> 替代。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Compoent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Boolean-屬性"><a href="#Boolean-屬性" class="headerlink" title="Boolean 屬性"></a>Boolean 屬性</h4><p>在 JSX 中預設只有屬性名稱但沒設值為 <code>true</code>，例如以下第一個 input 標籤 <code>disabled</code> 雖然沒設值，但結果和下面的 input 為相同：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">disabled</span> /&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">disabled</span>=<span class="string">&#123;true&#125;</span> /&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>反之，若是沒有屬性，則預設預設為 <code>false</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> /&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">disabled</span>=<span class="string">&#123;false&#125;</span> /&gt;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-擴展屬性"><a href="#6-擴展屬性" class="headerlink" title="6. 擴展屬性"></a>6. 擴展屬性</h3><p>在 ES6 中使用 <code>...</code> 是迭代物件的意思，可以把所有物件對應的值迭代出來設定屬性，但要注意後面設定的屬性會蓋掉前面相同屬性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> props = &#123;</span><br><span class="line">  style: <span class="string">"width:20px"</span>,</span><br><span class="line">  className: <span class="string">"main"</span>,</span><br><span class="line">  value: <span class="string">"yo"</span>,  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;HelloMessage  &#123;...props&#125; value=<span class="string">"yo"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等於以下</span></span><br><span class="line">React.createElement(<span class="string">"h1"</span>, React._spread(&#123;&#125;, props, &#123;value: <span class="string">"yo"</span>&#125;), <span class="string">"Hello React!"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="7-自定義屬性"><a href="#7-自定義屬性" class="headerlink" title="7. 自定義屬性"></a>7. 自定義屬性</h3><p>若是希望使用自定義屬性，可以使用 <code>data-</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloMessage data-attr=<span class="string">"xd"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-顯示-HTML"><a href="#8-顯示-HTML" class="headerlink" title="8. 顯示 HTML"></a>8. 顯示 HTML</h3><p>通常為了避免資訊安全問題，我們會過濾掉 HTML，若需要顯示的話可以使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;_html: '<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-樣式使用"><a href="#9-樣式使用" class="headerlink" title="9. 樣式使用"></a>9. 樣式使用</h3><p>在 JSX 中使用外觀樣式方法如下，第一個 <code>{}</code> 是 JSX 語法，第二個為 JavaScript 物件。與一般屬性值用 <code>-</code> 分隔不同，為駝峰式命名寫法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloMessage style=&#123;&#123; color: <span class="string">'#FFFFFF'</span>, fontSize: <span class="string">'30px'</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="10-事件處理"><a href="#10-事件處理" class="headerlink" title="10. 事件處理"></a>10. 事件處理</h3><p>事件處理為前端開發的重頭戲，在 JSX 中透過 inline 事件的綁定來監聽並處理事件（注意也是駝峰式寫法）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HelloMessage onClick=&#123;<span class="keyword">this</span>.onBtn&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以上就是 JSX 簡明入門教學，希望透過以上介紹，讓讀者了解在 React 中為何要使用 JSX，以及 JSX 基本概念和用法。最後為大家複習一下：在 React 世界裡，所有事物都是以 Component 為基礎，通常會將同一個 Compoent 相關的程式和資源都放在一起，而在撰寫 React Component 時我們常會使用 <a href="https://facebook.github.io/jsx/" target="_blank" rel="external">JSX</a> 的方式來提升程式撰寫效率。JSX 是一種語法類似 XML 的 ECMAScript 語法擴充，可以善用 JavaScript 的強大能力，放棄蹩腳的模版語言。當然 JSX 並非強制使用，你也可以選擇不用，因為最終 JSX 的內容會轉化成 JavaScript。當相信閱讀完上述的內容後，你會開始認真考慮使用 JSX 的語法。</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://www.puritys.me/docs-blog/article-320-Imperative-programming-or-declarative-programming.html" target="_blank" rel="external">Imperative programming or declarative programming</a></li>
<li><a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX in Depth</a></li>
<li><a href="https://www.gitbook.com/book/kdchang/react101/details" target="_blank" rel="external">從零開始學 React（ReactJS 101）</a></li>
</ol>
<p>image via <a href="http://www.adweek.com/socialtimes/files/2014/05/LikeButtoniOSApps650.jpg" target="_blank" rel="external">adweek</a>, <a href="http://codecondo.com/wp-content/uploads/2015/12/Useful-Features-of-React_7851.png" target="_blank" rel="external">codecondo</a></p>
<p>關於作者：<br><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; iOS/Android lover. Keep Shipping Cool Mobile App &amp; Web App.:)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用 DDS 開發 ROS 2.0]]></title>
      <url>http://blog.techbridge.cc/2016/04/15/ros-2-dds/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章想要向大家介紹ROS 2.0的底層實作概念，雖然比較不會有程式實作的討論，但我覺得這一塊的深度滿值得介紹的，因為使用ROS有好幾種層次:</p>
<ol>
<li>使用ROS的各種工具來建立自己的應用</li>
<li>在開發上碰到一些問題，修改現成的package來滿足自己的需求</li>
<li>開發自己的演算法，發布自己的package給其他人使用</li>
<li>協助開發與維護ROS的核心</li>
</ol>
<p>這篇文章要討論的議題已經落在第四個層次，所以對於一般的使用者來說，可能不太具有直接應用的價值，但如果對於ROS的底層實作有更深入的理解(知道他是怎麼開發出來的、有哪些限制、有哪些優點)，就可以在利用ROS撰寫自己的應用時，更能開發出效能最佳化的應用。</p>
<h2 id="為什麼要開發ROS-2-0"><a href="#為什麼要開發ROS-2-0" class="headerlink" title="為什麼要開發ROS 2.0?"></a>為什麼要開發ROS 2.0?</h2><p>事實上，如果ROS 1.0 已經足夠完美，那我們就沒有必要討論ROS 2.0。不過事情當然不是這樣，因為ROS 1.0在開發的時候，是圍繞著一隻機器人來開發的，雖然當初的設計已經讓ROS變得很有彈性，可以被應用在各式各樣的機器人上，但是隨著使用者越來越多，超乎開發者想像的使用情境也越來越多。</p>
<p>也就是說，如果開發者們不積極地開始開發下一代的ROS，遲早會無法滿足越來越複雜而多樣化的需求。對於這些使用情境的具體描述，可以參考<a href="http://po-jen.github.io/design/articles/why_ros2.html#section-1" target="_blank" rel="external">這裡</a>。</p>
<h2 id="開發ROS系統需要實現的模塊"><a href="#開發ROS系統需要實現的模塊" class="headerlink" title="開發ROS系統需要實現的模塊"></a>開發ROS系統需要實現的模塊</h2><p>首先來談論一下建立整個系統上，需要考慮的幾個重點:</p>
<ul>
<li>Discovery功能</li>
<li>Publisher-Subscriber功能</li>
<li>Service 與 Action功能</li>
</ul>
<p>Discovery功能的意義是，只要有新的node啟動，就能在整個ROS node的網路中被看見(概念很像是我打開手機的wifi熱點分享，其他裝置就應該要可以發現有這個wifi熱點)。</p>
<p>接下來的Publisher-Subscriber功能、Service功能跟Action功能其實就是ROS使用者熟悉的Topic、Service跟Actionlib啦，本質上這幾種功能在處理的都是node之間的溝通(也就是程式之間的溝通，大家可以想像要讓一隻機器人正常運作，電腦上需要運行的程式一定是很多個，而且需要彼此溝通，所以底層的溝通機制需要有人來實作，不然就是…想開發機器人程式的你得自己實作)。如果你不太確定自己知不知道我在說什麼，可以看看這一篇<a href="https://pojenlai.wordpress.com/2012/11/03/ros-topic-service-and-actionlib/" target="_blank" rel="external">區分Topic、Service跟Actionlib的文章</a>。</p>
<h2 id="DDS的系統層概念"><a href="#DDS的系統層概念" class="headerlink" title="DDS的系統層概念"></a>DDS的系統層概念</h2><p>想要實作上面這些功能，DDS並不是唯一的選擇，但是，OSRF(Open Source Robotic Foundation)的開發者經過嘗試之後，覺得這是最好的開發選項。細節理由可以看延伸閱讀的第3篇文章，這部分已經有中文翻譯了。</p>
<p><img src="/img/pojenlai/api_levels.png" alt="api_levels"></p>
<p>從上面這張圖可以清楚地看出，使用者所需要接觸到的只有最上面的兩層。使用者自己寫的code就屬於Userland Code，而使用者自己寫的code中呼叫到的ROS API (例如ros::init())就屬於ROS client library API，而DDS的API則是在更底層被ROS client library API所使用。</p>
<p>有趣的地方是，為了保持彈性，OSRF的開發者們希望使用者可以自己選擇底層使用的是哪一個版本的DDS (DDS像是一種標準，所以可以有不同公司提供自己的實作版本)。</p>
<h2 id="一點細節的延伸"><a href="#一點細節的延伸" class="headerlink" title="一點細節的延伸"></a>一點細節的延伸</h2><p>上面討論的都是概念的理解，對於技術有興趣的你想必沒辦法接受，所以就讓我們來看一點技術細節吧!</p>
<p>我們還是一樣先站在開發者的角度，最基本我們需要提供的工具就是Node初始化的函式對吧，這個函式的長相就像:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Node::Node(<span class="built_in">std</span>::<span class="built_in">string</span> name): running_(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*----------------------親切的中文註解來囉!!!----------------------*/</span></span><br><span class="line">	nodes_.push_back(<span class="keyword">this</span>);</span><br><span class="line">	subscription_iterator_ = subscriptions_.end();</span><br><span class="line">	name_ = name;</span><br><span class="line">	<span class="comment">//取得了DDS的DomainParticipantFactory的instance，很像是一個node產生器的感覺</span></span><br><span class="line">	dpf_ = DDS::DomainParticipantFactory::get_instance();</span><br><span class="line">	checkHandle(dpf_.in(), <span class="string">"DDS::DomainParticipantFactory::get_instance"</span>);</span><br><span class="line">	DDS::DomainId_t domain = DDS::DOMAIN_ID_DEFAULT;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//實際產生一個participant，應該就是一個node</span></span><br><span class="line">	participant_ = create_participant( domain, PARTICIPANT_QOS_DEFAULT, NULL,DDS::STATUS_MASK_NONE);</span><br><span class="line">	checkHandle(participant_.in(), <span class="string">"DDS::DomainParticipantFactory::create_participant"</span>);</span><br><span class="line">	<span class="comment">/*----------------------看到這裡就好囉!!!----------------------*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the default QoS for Topics</span></span><br><span class="line">	DDS::ReturnCode_t status = participant_get_default_topic_qos(default_topic_qos_);</span><br><span class="line">	checkStatus(status, <span class="string">"DDS::DomainParticipant::get_default_topic_qos"</span>);</span><br><span class="line">	default_topic_qos_.reliability.kind = DDS::BEST_EFFORT_RELIABILITY_QOS;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the default QoS for Publishers</span></span><br><span class="line">	status = participant_get_default_publisher_qos(default_publisher_qos_);</span><br><span class="line">	checkStatus(status, <span class="string">"DDS::DomainParticipant::get_default_publisher_qos"</span>);</span><br><span class="line">	default_publisher_qos_.partition.name.length(<span class="number">1</span>);</span><br><span class="line">	default_publisher_qos_.partition.name[<span class="number">0</span>] = <span class="string">"ros_partition"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the default QoS for Subscribers</span></span><br><span class="line">	status = participant_get_default_subscriber_qos(default_subscriber_qos_);</span><br><span class="line">	checkStatus(status, <span class="string">"DDS::DomainParticipant::get_default_publisher_qos"</span>);</span><br><span class="line">	default_subscriber_qos_.partition.name.length(<span class="number">1</span>);</span><br><span class="line">	default_subscriber_qos_.partition.name[<span class="number">0</span>] = <span class="string">"ros_partition"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create a waitset for spin</span></span><br><span class="line">	waitset_ = new DDS::WaitSet();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a parameter server for this node</span></span><br><span class="line">	create_parameter_server(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家先不要嚇到，一下有太多細節本來就不可能看懂，大家只需要看我用註解標記起來的區域，體驗一下什麼叫做ROS client library API呼叫DDS API的感覺就好。</p>
<p>那對於一個使用者來說，假設我今天要啟動一隻機器人，那就需要呼叫建立node的函式，看起來就像:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TurtleApp(<span class="keyword">int</span>&amp; argc, <span class="keyword">char</span>** argv): QApplication(argc, argv)</span><br><span class="line">&#123;</span><br><span class="line">	rclcpp::init(argc, argv);</span><br><span class="line">	nh_ = rclcpp::create_node(<span class="string">"turtlesim"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你一定覺得奇怪，rclcpp::create_node()跟上面我講的Node::Node()建構子根本接不起來啊? 所以這邊就要補上一點點程式碼，想必你就懂了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rclcpp::init(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (globally_initialized)</span><br><span class="line">	&#123;</span><br><span class="line">		throw AlreadyInitializedError();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Register a signal handler so DDS doesn not just sit there... */</span></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGINT, Node::static_signal_handler) == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"An error occurred while setting a signal handler.\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	globally_initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node::Ptr rclcpp::create_node(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">&#123;</span><br><span class="line">	return Node::Ptr(new Node(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>OK!簡介就到這邊啦，如果對於實作細節有興趣深入的讀者，不妨去看看ROS 2.0的github repo，詳細的程式碼全部都是開源的，所以可以從中學習開發的細節。</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://po-jen.github.io/design/articles/why_ros2.html" target="_blank" rel="external">為什麼要開發ROS 2.0?</a></li>
<li><a href="http://po-jen.github.io/design/articles/ros_with_zeromq.html" target="_blank" rel="external">使用ZeroMQ跟相關的函式庫來開發ROS</a></li>
<li><a href="http://po-jen.github.io/design/articles/ros_on_dds.html" target="_blank" rel="external">使用DDS來開發ROS</a> (仍在趕工中，歡迎開issue催促翻譯者QQ)</li>
<li><a href="https://github.com/ros2/ros2/wiki" target="_blank" rel="external">ROS 2.0 wiki</a></li>
<li><a href="https://github.com/osrf/ros_dds/tree/master/prototype" target="_blank" rel="external">ROS DDS Prototype (Github Repo)</a></li>
</ol>
<p>關於作者：<br><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一看就懂的 React ES5、ES6+ 常見用法對照表]]></title>
      <url>http://blog.techbridge.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/</url>
      <content type="html"><![CDATA[<p><img src="/img/kdchang/react-es6.jpg" alt="一看就懂的 React ES5、ES6+ 常見用法對照表"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> 是 Facebook 推出的開源 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a> Library。自從 React 正式開源後，React 生態系開始蓬勃發展。事實上，透過學習 React 生態系（ecosystem）的過程中，可以讓我們順便學習現代化 Web 開發的重要觀念（例如：ES6、<a href="https://github.com/webpack/webpack" target="_blank" rel="external">Webpack</a>、<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>、模組化等），成為更好的開發者。雖然 ES6（ECMAScript2015）、ES7 是未來趨勢（本文將 ES6、ES7 稱為 ES6+），然而目前在網路上有許多的學習資源仍是以 ES5 為主，導致讀者在學習上遇到一些坑洞和迷惑（本文假設讀者對於 React 已經有些基本認識，若你對於 React 尚不熟悉，建議先行<a href="https://facebook.github.io/react/" target="_blank" rel="external">閱讀官方文件</a>和<a href="https://scotch.io/tutorials/learning-react-getting-started-and-concepts" target="_blank" rel="external">本篇入門教學</a>）。因此本文希望透過整理在 React 中 ES5、ES6+ 常見用法對照表，讓讀者們可以在實現功能時（尤其在 <a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>）可以更清楚兩者的差異，無痛轉移到 ES6+。 </p>
<h2 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h2><ol>
<li>Modules</li>
<li>Classes</li>
<li>Method definition</li>
<li>Property initializers</li>
<li>State</li>
<li>Arrow functions</li>
<li>Dynamic property names &amp; template strings</li>
<li>Destructuring &amp; spread attributes</li>
<li>Mixins</li>
<li>Default Parameters</li>
</ol>
<h2 id="1-Modules"><a href="#1-Modules" class="headerlink" title="1. Modules"></a>1. Modules</h2><p>隨著 Web 技術的進展，模組化開發已經成為一個重要課題。關於 JavaScript 模組化我們這邊不詳述，建議讀者參考 <a href="http://huangxuan.me/js-module-7day/#/" target="_blank" rel="external">這份投影片</a> 和 <a href="http://justineo.github.io/singles/writing-modular-js/" target="_blank" rel="external">這篇文章</a>。</p>
<p>ES5 若使用 CommonJS 標準，一般使用 <code>require()</code> 用法引入模組：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> MyComponent = <span class="built_in">require</span>(<span class="string">'./MyComponent'</span>);</span><br></pre></td></tr></table></figure>
<p>輸出則是使用 <code>module.exports</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = MyComponent;</span><br></pre></td></tr></table></figure>
<p>ES6+ <code>import</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</span><br></pre></td></tr></table></figure>
<p>輸出則是使用 <code>export default</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Compoent</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Classes"><a href="#2-Classes" class="headerlink" title="2. Classes"></a>2. Classes</h2><p>在 React 中元件（Component）是組成視覺頁面的基礎。在 ES5 中我們使用 <code>React.createClass()</code> 來建立 Component，而在 ES6+ 則是用 <a href="https://babeljs.io/docs/learn-es2015/#classes" target="_blank" rel="external">Classes</a> 繼承 <code>React.Component</code> 來建立 Component。若是有寫過 Java 等物件導向語言（OOP）的讀者應該對於這種寫法比較不陌生，不過要注意的是 JavaScript 仍是原型繼承類型的物件導向程式語言，只是使用 <code>Classes</code> 讓物件導向使用上更加直觀。對於選擇 <code>class</code> 使用上還有疑惑的讀者建議可以閱讀 <a href="https://toddmotto.com/react-create-class-versus-component/" target="_blank" rel="external">React.createClass versus extends React.Component</a> 這篇文章。</p>
<p>ES5 <code>React.createClass()</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.description&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    	);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Photo</span> /&gt;</span>, document.getElementById('main'));</span></span><br></pre></td></tr></table></figure>
<p>ES6+ <code>class</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.description&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Photo</span> /&gt;</span>, document.getElementById('main'));</span></span><br></pre></td></tr></table></figure>
<p>在 ES5 我們會在 <code>componentWillMount</code> 生命週期定義希望在 <code>render</code> 前執行，且只會執行一次的任務：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 則是定義在 <code>constructor</code> 建構子中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 原本在 componentWillMount 操作的動作可以放在這</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Method-definition"><a href="#3-Method-definition" class="headerlink" title="3. Method definition"></a>3. Method definition</h2><p>在 ES6 中我們使用 <code>Method</code> 可以忽略 <code>function</code> 和 <code>,</code>，使用上更為簡潔！ES5 <code>React.createClass()</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6+ class 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(e) &#123;&#125;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Property-initializers"><a href="#4-Property-initializers" class="headerlink" title="4. Property initializers"></a>4. Property initializers</h2><p>Component 屬性值是資料傳遞重要的元素，在 ES5 中我們使用 <code>propTypes</code> 和  <code>getDefaultProps</code> 來定義屬性（props）的預設值和型別：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      checked: <span class="literal">false</span>,</span><br><span class="line">      maxLength: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  propTypes: &#123;</span><br><span class="line">    checked: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLength: React.PropTypes.number.isRequired</span><br><span class="line">  &#125;,</span><br><span class="line">  render: fucntion() &#123;</span><br><span class="line">  	<span class="keyword">return</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 中我們則是參考 <a href="https://github.com/jeffmo/es-class-fields-and-static-properties" target="_blank" rel="external">ES7 property initializers</a> 使用 <code>class</code> 中的靜態屬性（static properties）來定義：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    checked: <span class="literal">false</span>,</span><br><span class="line">    maxLength: <span class="number">10</span>,</span><br><span class="line">  &#125;; <span class="comment">// 注意有分號</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    checked: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLength: React.PropTypes.number.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">  	<span class="keyword">return</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6+ 另外一種寫法，可以留意一下，主要是看各團隊喜好和規範，選擇合適的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Todo.defaultProps = &#123;</span><br><span class="line">    checked: false,</span><br><span class="line">    maxLength: 10,</span><br><span class="line">&#125;;</span><br><span class="line">Todo.propTypes = &#123;</span><br><span class="line">    checked: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLength: React.PropTypes.number.isRequired,</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-State"><a href="#5-State" class="headerlink" title="5. State"></a>5. State</h2><p>在 React 中 <code>Props</code> 和 <code>State</code> 是資料流傳遞的重要元素，不同的是 <code>state</code> 可更動，可以去執行一些運算。在 ES5 中我們使用 <code>getInitialState</code> 去初始化 <code>state</code>： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            maxLength: <span class="keyword">this</span>.props.maxLength,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 中我們初始化 <code>state</code> 有兩種寫法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        maxLength: <span class="keyword">this</span>.props.maxLength,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一種寫法，使用在建構式初始化。比較推薦使用這種方式，方便做一些運算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            maxLength: <span class="keyword">this</span>.props.maxLength,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Arrow-functions"><a href="#6-Arrow-functions" class="headerlink" title="6. Arrow functions"></a>6. Arrow functions</h2><p>在講 <code>Arrow functions</code> 之前，我們先聊聊在 React 中 <code>this</code> 和它所代表的 <code>context</code>。在 ES5 中，我們使用 <code>React.createClass()</code> 來建立 Component，而在 <code>React.createClass()</code> 下，預設幫你綁定好 <code>method</code> 的 <code>this</code>，你毋須自行綁定。所以你可以看到像是下面的例子，<code>callback function</code> handleButtonClick 中的  <code>this</code> 是指到 component 的實例（instance），而非觸發事件的物件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoBtn = React.createClass(&#123;</span><br><span class="line">    handleButtonClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 此 this 指到 component 的實例（instance），而非 button</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick&#125;</span>&gt;</span>&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然而自動綁定這種方式反而會讓人容易誤解，所以在 ES6+ 推薦使用 <code>bind</code> 綁定 <code>this</code> 或使用 <code>Arrow functions</code>（它會绑定當前 <code>scope</code> 的 <code>this context</code>）兩種方式，你可以參考下面例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    handleButtonClick(e)&#123;</span><br><span class="line">        <span class="comment">// 確認綁定 this 指到 component instance</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;toggle: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 這邊可以用 this.handleButtonClick.bind(this) 手動綁定或是 Arrow functions () =&gt; &#123;&#125; 用法</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick.bind(this)&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span> &#123;this.handleButtonClick(e)&#125; &#125;&gt;&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Arrow functions</code> 雖然一開始看起來有點怪異，但其實觀念很簡單：一個簡化的函數。函數基本上就是參數（不一定要有參數）、表達式、回傳值（也可能是回傳 undefined）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Arrow functions 的一些例子</span><br><span class="line">()=&gt;7</span><br><span class="line">e=&gt;e+2</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    alert(&apos;XD&apos;);</span><br><span class="line">&#125;</span><br><span class="line">(a,b)=&gt;a+b</span><br><span class="line">e=&gt;&#123;</span><br><span class="line">    if (e == 2)&#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 100/e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不過要注意的是無論是 <code>bind</code> 或是 <code>Arrow functions</code>，每次執行回傳都是指到一個新的函數，若需要再調用到這個函數，請記得先把它存起來：</p>
<p>錯誤用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        Btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidmount()&#123;</span><br><span class="line">        Btn.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused(event)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正確用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.handleButtonClick = <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        Btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidmount()&#123;</span><br><span class="line">        Btn.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多 Arrows and Lexical This 特性可以<a href="https://babeljs.io/docs/learn-es2015/#arrows" target="_blank" rel="external">參考這個文件</a>。</p>
<h2 id="7-Dynamic-property-names-amp-template-strings"><a href="#7-Dynamic-property-names-amp-template-strings" class="headerlink" title="7. Dynamic property names &amp; template strings"></a>7. Dynamic property names &amp; template strings</h2><p>以前在 ES5 我們要動態設定屬性名稱時，往往需要多寫幾行程式碼才能達到目標：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</span><br><span class="line">  onChange: <span class="function"><span class="keyword">function</span>(<span class="params">inputName, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stateToSet = &#123;&#125;;</span><br><span class="line">    stateToSet[inputName + <span class="string">'Value'</span>] = e.target.value;</span><br><span class="line">    <span class="keyword">this</span>.setState(stateToSet);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但在 ES6+中，透過 <a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">enhancements to object literals</a> 和 <a href="https://babeljs.io/docs/learn-es2015/#template-strings" target="_blank" rel="external">template strings</a> 可以輕鬆完成動態設定屬性名稱的任務：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Todo extends React.Component &#123;</span><br><span class="line">  onChange(inputName, e) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [`$&#123;inputName&#125;Value`]: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Template Strings 是一種語法糖（syntactic sugar），方便我們組織字串（這邊也用上 <code>let</code>、<code>const</code> 變數和常數宣告的方式，和 <code>var</code> 的 <code>function scope</code> 不同的是它們是屬於 <code>block scope</code>，亦即生存域存在於 <code>{}</code> 間）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interpolate variable bindings</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">"Bob"</span>, <span class="keyword">let</span> = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span> \\ Hello Bob, how are you today?</span><br></pre></td></tr></table></figure>
<h2 id="8-Destructuring-amp-spread-attributes"><a href="#8-Destructuring-amp-spread-attributes" class="headerlink" title="8. Destructuring &amp; spread attributes"></a>8. Destructuring &amp; spread attributes</h2><p>在 React 的 Component 中，父元件利用 <code>props</code> 來傳遞資料到子元件是常見作法，然而我們有時會希望只傳遞部分資料，此時 ES6+ 中的 <a href="https://babeljs.io/docs/learn-es2015/#destructuring" target="_blank" rel="external">Destructuring</a> 和 <a href="https://facebook.github.io/react/docs/jsx-spread.html" target="_blank" rel="external">JSX 的 Spread Attributes
</a> ，<code>...</code> Spread Attributes 主要是用來迭代物件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> &#123;</span><br><span class="line">      className,</span><br><span class="line">      ...others,  <span class="comment">// ...others 包含 this.props 除了 className 外所有值。this.props = &#123;value: 'true', title: 'header', className: 'content'&#125;</span></span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TodoList</span> &#123;<span class="attr">...others</span>&#125; /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoadMoreClick&#125;</span>&gt;</span>Load more<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但使用上要注意的是若是有重複的屬性值則以後來覆蓋，下面的例子中若 <code>...this.props</code>，有 <code>className</code>，則被後來的 <code>main</code> 所覆蓋：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &#123;...this.props&#125; className=<span class="string">"main"</span>&gt;</span><br><span class="line">  …</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>而 <code>Destructuring</code> 也可以用在簡化 <code>Module</code> 的引入上，這邊我們先用 ES5 中引入方式來看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</span><br><span class="line"><span class="keyword">var</span> Component = React.component;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</span><br></pre></td></tr></table></figure>
<p>以下 ES5 寫法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var React = require(&apos;react-native&apos;);</span><br><span class="line">var View = React.View;</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 則可以直接使用 <code>Destructuring</code> 這種簡化方式來引入模組中的元件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 這邊等於上面的寫法</span><br><span class="line">var &#123; View &#125; = require(&apos;react-native&apos;);</span><br></pre></td></tr></table></figure>
<p>更進一步可以使用 <code>import</code> 語法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">	View,</span><br><span class="line">	Component,</span><br><span class="line">	Text,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</span><br></pre></td></tr></table></figure>
<h2 id="9-Mixins"><a href="#9-Mixins" class="headerlink" title="9. Mixins"></a>9. Mixins</h2><p>在 ES5 中，我們可以使用 <code>Mixins</code> 的方式去讓不同的 Component 共用相似的功能，重用我們的程式碼：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但由於官方不打算在 ES6+ 中繼續推行 <code>Mixins</code>，若還是希望使用，可以參考看看<a href="https://www.npmjs.com/package/es6-class-mixin" target="_blank" rel="external">第三方套件</a>或是<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" target="_blank" rel="external">這個文件的用法</a>。</p>
<h2 id="10-Default-Parameters"><a href="#10-Default-Parameters" class="headerlink" title="10. Default Parameters"></a>10. Default Parameters</h2><p>以前 ES5 我們函數要使用預設值需要這樣使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span> (<span class="params">height, color</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;  </span><br><span class="line">    <span class="keyword">var</span> color = color || <span class="string">'red'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在 ES6+ 的函數可以支援預設值，讓程式碼更為簡潔：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height = 50, color = 'red'</span>) </span>&#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以上就是 React ES5、ES6+常見用法對照表，能看到這邊的你應該已經對於 React ES5、ES6 使用上有些認識，先給自己一些掌聲吧！確實從 ES6 開始，JavaScript 和以前我們看到的 JavaScript 有些不同，增加了許多新的特性，有些讀者甚至會很懷疑說這真的是 JavaScript 嗎？ES6 的用法對於初學者來說可能會需要寫一點時間吸收，下面我幫大家準備了延伸閱讀，方便大家進一步參考學習。接下來我們也會有一系列從零開始學 React 的文章來帶大家由淺入深學習 ReactJS 生態系，運用 JavaScript 打造跨平台應用程式。筆者才書學淺，若有疏漏歡迎大家一起交流討論：）</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8" target="_blank" rel="external">React/React Native 的ES5 ES6写法对照表</a></li>
<li><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">React on ES6+</a></li>
<li><a href="http://www.ghugo.com/react-native-es6/" target="_blank" rel="external">react native 中es6语法解析</a> </li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">Learn ES2015</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a></li>
<li><a href="https://facebook.github.io/react/index.html" target="_blank" rel="external">React官方網站</a></li>
<li><a href="http://fraserxu.me/intro-to-react/" target="_blank" rel="external">React INTRO TO REACT.JS</a></li>
<li><a href="https://toddmotto.com/react-create-class-versus-component/" target="_blank" rel="external">React.createClass versus extends React.Component</a></li>
<li><a href="https://github.com/lzbSun/react-native-coding-style" target="_blank" rel="external">react-native-coding-style</a></li>
<li><a href="https://github.com/airbnb/javascript/tree/master/react" target="_blank" rel="external">Airbnb React/JSX Style Guide</a></li>
<li><a href="https://www.gitbook.com/book/kdchang/react101/details" target="_blank" rel="external">從零開始學 React（ReactJS 101）</a></li>
</ol>
<p>關於作者：<br><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; iOS/Android lover. Keep Shipping Cool Mobile App &amp; Web App.:)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Browser Rendering Optimization]]></title>
      <url>http://blog.techbridge.cc/2016/04/02/Browser-Rendering-Optimization/</url>
      <content type="html"><![CDATA[<blockquote>
<p>“My name is Barry Allen, and I’m the fastest man alive …”<br>“Wait..reverse flash is faster then you, zoom is faster than you..”<br><a id="more"></a></p>
</blockquote>
<p>今天來談談Browser Rendering Optimisation。</p>
<p>相信大家小時候都好奇過早期的電影、卡通或動畫，是怎麼樣製作出來的，而我們也都知道基本上就是一連串的<code>畫面</code>以非常快速的方式做切換，矇騙你的視覺讓你感受到是連續的<code>影片</code>，而Browser其實也是類似的做法，當取得Server的回應後，瀏覽器便把接收到的HTML畫出來，而每當你的網頁有所變化時，Browser就會再依據其邏輯將網頁重新渲染一遍，也因此才能看到這麼多漂亮的效果。</p>
<p>而所謂browser rendering optimization就是要讓渲染的過程能夠更快速、更順暢，讓你的網頁畫面如夢似幻、細緻耀眼。</p>
<p>要做到這件事情，就必須提及FPS(Frames per Second)，顧名思義就是每秒畫幾個Frames，一般影片大概是<a href="https://en.wikipedia.org/wiki/Frame_rate" target="_blank" rel="external">30fps</a>，而多數螢幕畫面的更新頻率是60Hz，因此若我們能將fps極致提升到60fps，理當能有非常棒的畫面呈現！</p>
<p>知道目標後，let’s do some math…<br><code>60fps = 60 frames per second = 60 frames every 1000ms</code><br>好的從我們優異的數學能力下得知，要達到60fps，我們繪製一個frames的時間必須在16.6666…ms左右(1000/60)</p>
<p>ok，那要怎麼知道自己的網頁每個frames花了多少時間繪製？拜Google大神所賜，只要打開Chrome的devTool，切換到Timeline的tab，就可以很容易的知道網頁在browser上的render時間。讓我們用畫面超級old school的pchome拍賣來Demo一下：</p>
<p><img src="/img/arvinh/googleDevTool-pchome.png" alt="Devtool-timeline(點圖放大)" title="DevTool-timeline"></p>
<p>先別被圖中五顏六色的區塊嚇到，在我們說明這Tool該如何使用之前，必須先瞭解Browser的Render過程，以及這圖片中每個顏色所代表的意義。</p>
<p>接觸過HTML的人一定都知道所謂的DOM Tree，Browser會解析HTML並轉換成DOM Tree做操作，但知道<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en" target="_blank" rel="external">Render Tree</a>的人可能就不多了，Render tree由DOM tree與CSS結合產生，Browser就是依照Render Tree來決定該在畫面上呈現什麼東西。若你今天在某個div的css上加上<code>display: none</code>，那這個div就不會再Render tree上呈現。</p>
<p><img src="/img/arvinh/RenderTree.png" alt="Render Tree (source from google)"></p>
<p>既然Render的過程也是一棵Tree，有點概念的人可能會想：每次style改變或是我更動DOM的位置時，這棵Tree也就會變動了吧？<br>沒錯！在整個Browser的Render過程中，就是會不斷去recalculating style、layout的關係，來建構這棵樹。</p>
<p>當然Browser的渲染過程不止這些，還必須載入js, css, web api等等的資源，因此有所謂的Rendering Pipeline</p>
<p><img src="/img/arvinh/render_pipeline.png" alt="Render Pipeline (source from google)"><br>從圖上可以發現其順序為：</p>
<ol>
<li>Javascript: 載入與執行JS/CSS</li>
<li>Style: 根據js與css計算style</li>
<li>Layout: 當style套入元素時，瀏覽器要檢查是否會影響到整個畫面的排列，並進行排列</li>
<li>Paint: 排列後有更動到的元素需要重新繪製（第一次載入的話當然是全部繪製）</li>
<li>Composite: 最後就是將所有元素重新合成回來（重新繪製的元素與原本的元素）</li>
</ol>
<p>實際上並非每次的前端更動都會執行這五個步驟，若你只有切換顏色、圖片等不影響版面配置的動作，browser會跳過Layout，直接進行Paint；或著你捲動網頁、css的動畫效果，這類操作則會跳過style與layout，直接進行Composite。</p>
<p>接下來我們回到Timeline這個tool。</p>
<p><img src="/img/arvinh/Timeline2.png" alt="Timeline record"><br>你可以直接在你想觀察的網頁打開Timeline，並重新整理，他就會自行錄製；或是你可以在你想觀察的操作步驟進行前（ex. 滑動頁面、打開menu bar等等）按下錄製。</p>
<p><img src="/img/arvinh/Timeline3.png" alt="Timeline finish"></p>
<p>接著在你覺得適合的地方（通常就是步驟執行完後）按下Finish。</p>
<p><img src="/img/arvinh/Timeline1.png" alt="Timeline result"></p>
<p>基本上就能得到下列的Timeline結果。<br>從這張圖片可以清楚看到每個frame花了多少時間，在Render pipeline中發生了哪些事情，值得注意的是，圖片右上角有個紅色小三角形，若你的frame中有這個標記，就代表Chrome認為這段frame有可以改善的部分。大家不妨到自己的網頁打開Timeline，看看有多少東西需要改進XD</p>
<p>在認識了工具後，總是要實際操作一遍才會有感受，這邊以三種角度來進行Optimization。</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>一般來說，前端工程師常常會利用<code>setTimeout</code>或是<code>setInterval</code>來製作一些動畫效果，你可能會寫下面這樣的code:</p>
<p><a href="https://jsbin.com/xuconawipi/5/edit?html,js,output" target="_blank" rel="external">example setInterval</a></p>
<figure class="highlight javascript"><figcaption><span>setInterval.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;time: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">timer</span>) </span>&#123; </span><br><span class="line">  timer.time = timer.time+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">"#counter"</span>).innerHTML = timer.time;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(counter.bind(<span class="literal">null</span>,timer), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>或著是</p>
<p><a href="https://jsbin.com/yocokorelu/edit?html,js,output" target="_blank" rel="external">example setTimeout</a><br><figure class="highlight javascript"><figcaption><span>setTimeout.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;time: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">timer</span>) </span>&#123; </span><br><span class="line">	setTimeout(counter.bind(<span class="literal">null</span>,timer), <span class="number">1000</span>);</span><br><span class="line">	timer.time = timer.time+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">document</span>.querySelector(<span class="string">"#counter"</span>).innerHTML = timer.time;</span><br><span class="line">&#125;</span><br><span class="line">counter(timer);</span><br></pre></td></tr></table></figure></p>
<p>兩者都可以讓你達到同樣的效果，但是setTimeout跟setInterval對Browser來說都有個主要缺點，就是他<strong><span style="color:red; font-style: italic;">想執行時就會執行，而不會依據你的Browser狀況<span></span></span></strong>；另外當你切換到別的Tab時，setTimeout還會繼續Render。（理論上user看不到畫面，Browser就可以不用執行，以節省效能）<br><em><span style="color:rgba(228, 85, 85, 0.81); font-style: italic;">不過現在許多瀏覽器都已經利用某些方式讓setTimeout在不需要Render時暫停工作。</span></em></p>
<p>除了setTimeout與setInterval外，我們其實還有另一個選擇 <span style="color:red;"><code>requestAnimationFrame</code></span></p>
<p>假設我們有個Draw的動畫function，用setTimeout是這樣實作：<br><figure class="highlight javascript"><figcaption><span>draw.js	</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(draw, <span class="number">16</span>); <span class="comment">// 16ms per frame!</span></span><br><span class="line">    <span class="comment">// Drawing</span></span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure></p>
<p>若是用requestAnimationFrame：<br><figure class="highlight javascript"><figcaption><span>draw-RAF.js	</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// Drawing</span></span><br><span class="line">	requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(draw);</span><br></pre></td></tr></table></figure></p>
<p>就這麼簡單，用了<span style="color:red;"><code>requestAnimationFrame</code></span>之後，Browser就會綜合考量javascript所產生的動畫，一起刷新螢幕，並在動畫不在viewport時，暫停工作，以節省資源。</p>
<p>當然你會想說，那如果我想控制animation的timing怎麼辦？以前面的counter例子來看，你可以這樣做：</p>
<p><a href="https://jsbin.com/qerude/edit?html,js,output" target="_blank" rel="external">example reqeustAnimationFrame</a><br><figure class="highlight javascript"><figcaption><span>RAF_timeer		</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;time: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">timer</span>) </span>&#123; </span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    requestAnimationFrame(counter.bind(<span class="literal">null</span>, timer));</span><br><span class="line">    timer.time = timer.time+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"#counter"</span>).innerHTML = timer.time;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">counter(timer);</span><br></pre></td></tr></table></figure></p>
<h2 id="Style-amp-Layout"><a href="#Style-amp-Layout" class="headerlink" title="Style &amp; Layout"></a>Style &amp; Layout</h2><p>除了JS外，在頁面上操作畫面大多免不了觸發<code>Style</code> &amp; <code>Layout</code>這兩個Render Pipeline的步驟。既然免不了這些步驟，我們能做的就是盡量<strong>減少</strong>這些步驟的產生，大家可以到這裡（<a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html" target="_blank" rel="external">How (not) to trigger a layout in WebKit</a>）看看在有哪些操作我們要盡量減少。</p>
<p>當然，光說不練感受不到差別，讓我們來練習一個例子：</p>
<p><a href="https://jsbin.com/yesika/edit?html,css,js,output" target="_blank" rel="external">example Layout trigger</a><br><figure class="highlight javascript"><figcaption><span>befor-optimization.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// noprotect</span></span><br><span class="line">  <span class="keyword">var</span> sizer = <span class="built_in">document</span>.querySelector(<span class="string">'.sizer'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.set-size'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.article .article-block'</span>);</span><br><span class="line">    <span class="keyword">var</span> i = ps.length;</span><br><span class="line">    <span class="keyword">var</span> size;</span><br><span class="line">    <span class="keyword">var</span> finalHeight = sizer.offsetHeight;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      ps[i].style.height = finalHeight + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/wukuzi/2/edit?html,css,js,output" target="_blank" rel="external">example Less Layout trigger</a><br><figure class="highlight javascript"><figcaption><span>after-optimization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// noprotect</span></span><br><span class="line">  <span class="keyword">var</span> sizer = <span class="built_in">document</span>.querySelector(<span class="string">'.sizer'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.set-size'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.article .article-block'</span>);</span><br><span class="line">    <span class="keyword">var</span> i = ps.length;</span><br><span class="line">    <span class="keyword">var</span> size;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      finalHeight = sizer.offsetHeight;</span><br><span class="line">      ps[i].style.height = finalHeight + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>仔細看就會發現其實只有一行code有變動，效果卻差很多！當你在操作類似DOM物件的時候可以參考上述的網站，避免不必要的re-layout動作。</p>
<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><p>在一個網頁的頁面當中，實際上並非是平面的，通常會由許多<code>Layer</code>所組成，而在Browser rendering pipeline的最後一個步驟<code>Composite</code>中，就是負責將這些Layer組合成完整的頁面。</p>
<p>我們這次以最近Live直播統一獅頗為熱門的Yahoo首頁為例子，依照先前的方式打開Dev tool中的Timeline，選取其中一段frame後，點選下方的<code>Layers</code>標籤，應該就可以看到類似下面的圖：<br><img src="/img/arvinh/layer.png" alt="Composite Layers"><br><img src="/img/arvinh/compositeLayers.png" alt="Composite Layers (而在Timeline的工具中，旁邊還能讓你拖拉旋轉，方便查看各個Layer的狀況。)"></p>
<p>可以發現yahoo首頁也是由許多層Layer所組成。</p>
<p>眼尖的讀者可能會發現為什麼頁面中只有一個區塊是綠色的？這就是這小節的重點了，在Composite的過程中，只有需要重新Style與Layout的Layer才需要重繪，而這些需要重繪的Layer就會被標註成綠色；以yahoo首頁為例，綠色的那條是影音列表，理當會不斷變動，因此會被Highlight為綠色。</p>
<p>那為什麼我們需要針對這個步驟做Optimize呢？因為假如在同一層layer中，你其實只有某一個div需要re-layout，但由於是在同一個Layer，會變成整個Layer都需要重新繪製，如此一來就會增加不必要的負擔。</p>
<p>因此我們可以在你確定會需要重繪制的div中，加入<code>will-change: transform;</code>這個屬性，告訴browser說，“欸~我知道我可能會變動喔，請不要把大家跟我視為一樣的”，這樣就能解決上述的問題。</p>
<p>大家不妨打開自己的網站，利用Chrome的Timeline玩看看，提升頁面的渲染效率，讓我們一起追求60ps的極致快感吧！</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html" target="_blank" rel="external">How not to trigger layout in webkit</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/?hl=en" target="_blank" rel="external">Google Web Fundamentals</a></li>
<li><a href="http://www.html5rocks.com/zh/tutorials/speed/layers/" target="_blank" rel="external">Accelerated Rendering in Chrome</a></li>
</ol>
<p>關於作者：<br><a href="http://blog.arvinh.info/about/" target="_blank" rel="external">@arvinh</a> 前端攻城獅，熱愛數據分析和資訊視覺化</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[人人都會的 Android Apk 反編譯]]></title>
      <url>http://blog.techbridge.cc/2016/03/24/android-decompile-introduction/</url>
      <content type="html"><![CDATA[<p>對於 Android 工程師來說，了解如何反編譯可以增進自己對 Android 底層的理解，也可以思考如何保護自己的 apk 不被反編譯。</p>
<p>對於一般人來說，許多現成的工具可以幫助我們非常輕鬆的、只要打打幾個指令就可以反編譯 apk，看到 java source code，滿足自己的好奇心。</p>
<p>本篇文章只介紹一些工具的使用，適合初學者觀看。若是想了解更底層的知識，可以參考文末附上的延伸閱讀。</p>
<h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>首先，我們需要一個用來被破解的 apk，簡單用任何你平常熟悉的工具自己 build 一個就好了。基本架構很簡單，只要一個 <code>MainActivity</code> 跟兩個<code>TextView</code>就好：</p>
<figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView text = (TextView)findViewById(R.id.text);</span><br><span class="line">        text.setText(<span class="string">"Taiwan No1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><figcaption><span>activity_main.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>安裝到手機上之後，會看到這樣的畫面：</p>
<p><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/uVN5gnA0QC6PEdujMIZg_device-2016-03-20-152510.png" alt="device-2016-03-20-152510.png"></p>
<h2 id="實際動手"><a href="#實際動手" class="headerlink" title="實際動手"></a>實際動手</h2><p>好，這個就是我們要拿來測試的 apk 了！<br>接著你需要一些非常好用的工具：</p>
<ol>
<li><a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">apktool</a></li>
<li><a href="http://jd.benow.ca/" target="_blank" rel="external">jd-gui</a></li>
<li><a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="external">dex2jar</a></li>
</ol>
<p>如何安裝就不再贅述了，讀者們可以參考看看文件或是上網搜尋一下就會有一堆解答～<br><code>apktool</code>是拿來把 apk 拆開用的，可以反編譯 apk 之後，看到 <code>smali</code> 檔案跟 <code>resource</code><br><code>dex2jar</code>可以把 apk 轉成 jar，再用<code>jd-gui</code>檢視 java code</p>
<p>接著我們開啟 terminal，到剛剛那個示範 apk 的目錄底下，執行<code>apktool d APKNAME.apk</code><br><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/Ahk6ZkFOQm7ECISEyxMI_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-20%20%E4%B8%8B%E5%8D%883.32.47.png" alt="螢幕快照 2016-03-20 下午3.32.47.png"></p>
<p>執行以後，會自動生成一個<code>APKNAME</code>的資料夾，裡面就是反編譯出來的東西了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── AndroidManifest.xml</span><br><span class="line">├── apktool.yml</span><br><span class="line">├── original</span><br><span class="line">├── res</span><br><span class="line">└── smali</span><br></pre></td></tr></table></figure>
<p>其中比較值得講的是<code>smali</code>這個資料夾，其實這裡面就是你的 source code，只是格式不太一樣。<br>你可以在<code>smali</code>這資料夾裡面找到你的<code>MainActivity.java</code>，內容如下：<br>（覺得長得很奇怪是很正常的事，但是認真多看幾眼，你會發現其實沒那麼難懂）</p>
<figure class="highlight"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.class public Lapktest/huli/com/apkdecompile/MainActivity;</span><br><span class="line">.super Landroid/app/Activity;</span><br><span class="line">.source "MainActivity.java"</span><br><span class="line"></span><br><span class="line"># direct methods</span><br><span class="line">.method public constructor &lt;init&gt;()V</span><br><span class="line">    .locals 0</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 8</span><br><span class="line">    invoke-direct &#123;p0&#125;, Landroid/app/Activity;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"># virtual methods</span><br><span class="line">.method protected onCreate(Landroid/os/Bundle;)V</span><br><span class="line">    .locals 2</span><br><span class="line">    .param p1, "savedInstanceState"    # Landroid/os/Bundle;</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 12</span><br><span class="line">    invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">    .line 13</span><br><span class="line">    const v1, 0x7f040019</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V</span><br><span class="line"></span><br><span class="line">    .line 14</span><br><span class="line">    const v1, 0x7f0c0050</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;findViewById(I)Landroid/view/View;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    check-cast v0, Landroid/widget/TextView;</span><br><span class="line"></span><br><span class="line">    .line 15</span><br><span class="line">    .local v0, "text":Landroid/widget/TextView;</span><br><span class="line">    const-string v1, "Taiwan No1"</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V</span><br><span class="line"></span><br><span class="line">    .line 16</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>你可以仔細對照一下剛剛自己寫的 java code，會發現只是換了種格式而已：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_main);</span><br></pre></td></tr></table></figure>
<p>其實就等於</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.line <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> v1, <span class="number">0x7f040019</span></span><br><span class="line">invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V</span><br></pre></td></tr></table></figure>
<p>你可能會好奇，這個<code>0x7f040019</code>是哪來的？<br>事實上，你可以在<code>res/values/public.xml</code>這個檔案裡面找到答案：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">public</span> <span class="attr">type</span>=<span class="string">"layout"</span> <span class="attr">name</span>=<span class="string">"activity_main"</span> <span class="attr">id</span>=<span class="string">"0x7f040019"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>到這裡，應該就可以大概猜出 Android 在編譯時候的流程：</p>
<ol>
<li>把所有資源檔壓縮、處理並且包在一起，產生<code>id與記憶體位置對照表</code></li>
<li>把程式碼裡面所有的<code>R.xx.xxx</code>透過剛剛產生的表，換成實際的記憶體位置</li>
<li>把 java code 變成 smali code（有點像把 C 變成組合語言的程式碼那樣）</li>
</ol>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>在剛剛的<code>smali</code>裡面，有這麼一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.line <span class="number">15</span></span><br><span class="line">.local v0, <span class="string">"text"</span>:Landroid/widget/TextView;</span><br><span class="line"><span class="keyword">const</span>-string v1, <span class="string">"Taiwan No1"</span></span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V</span><br></pre></td></tr></table></figure>
<p>讓我們把<code>Taiwan No1</code>換成<code>T@iw@n n0!</code>。<br>還記得另一個<code>TextView</code>有用到<code>R.string.hello_world</code>嗎？<br>在<code>res/values/strings.xml</code>裡面，可以找到這一串的定義：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>確定都有改完以後，就可以把這些程式碼再度「組裝」回去。<br>還記得剛剛反編譯的指令嗎？<code>apktool d APK_NAME.apk</code><br>這邊的<code>d</code>就是<code>decompile</code>的意思，所以如果要逆向組裝回去，就是<code>b</code>，<code>build</code>。</p>
<p><code>apktool b APK_NAME</code></p>
<p>執行完之後可以在<code>APK_NAME/dist</code>下面找到一個 apk。<br>但要注意的是這個 apk 還沒有被 sign 過，因此無法安裝。<br>可以隨便生成一個 keystore 或是找現成的來簽署。<br><code>jarsigner -verbose -digestalg SHA1 -keystore ~/KEY.keystore APK_NAME.apk KEY_ALIAS</code></p>
<p>安裝完以後就會看到這樣的畫面：</p>
<p><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/RNKaPElHQA2BJ02proFr_device-2016-03-20-160501.png" alt="device-2016-03-20-160501.png"></p>
<p>沒錯！就是這麼簡單，一個 apk 就這樣被修改了！</p>
<p>可是<code>smali</code>的程式碼不好懂，能不能直接看到 java code呢？<br>這時候剛剛推薦的工具<code>dex2jar</code>與<code>jd-gui</code>就派上用場了<br>前者可以把 apk 變成 jar，後者可以開啟一個 jar 並且顯示 java code<br>兩個組合在一起，就可以直接看到原本的程式碼了</p>
<p><code>dex2jar</code>下載下來之後會有一堆的 shell script，<code>dex2jar</code>就是我們想要的那個<br><code>./d2j-dex2jar.sh app.apk</code><br>執行完之後會有一個 jar，用 jd-gui 打開，會看到你的程式碼一覽無遺：</p>
<p><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/zrnTKCQgT0OeIPbkkfp8_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-20%20%E4%B8%8B%E5%8D%884.10.15.png" alt="螢幕快照 2016-03-20 下午4.10.15.png"></p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>沒接觸過反編譯的人可能會很驚訝：什麼！要改掉一個 apk 居然這麼簡單！<br>沒錯，就是這麼簡單，而且這只是一個很基本的範例而已。事實上，你想要加入新的程式碼、加入新的資源（圖片、聲音等等）也是可以的。<br>也就是說，你不只可以修改，還可以擴充原本的 apk！</p>
<p>但也有些方法可以防止不肖人士反編譯 apk，例如說加殼、混淆、動態載入等，關於這些方法我們下次有機會再介紹給大家囉！</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="https://magiclen.org/android-decompiler/" target="_blank" rel="external">Android 反編譯與防止被反編譯</a></li>
<li><a href="http://aiur3908.blogspot.tw/2015/07/android-proguard.html" target="_blank" rel="external">[Android] 程式碼混淆(ProGuard)與反組譯</a></li>
<li><a href="http://blog.davidou.org/archives/553" target="_blank" rel="external">[Android] 反組譯 破解Android的apk安裝檔</a></li>
<li><a href="http://www.wangchenlong.org/2016/03/19/reverse-analyze-apk/" target="_blank" rel="external">反编译的常用工具与使用方法</a></li>
<li><a href="http://blog.csdn.net/wdaming1986/article/details/8299996" target="_blank" rel="external">Smali–Dalvik虚拟机指令语言–&gt;【android_smali语法学习一】</a></li>
<li><a href="http://blog.isming.me/2015/01/14/android-decompile-smali/" target="_blank" rel="external">android反编译-smali语法</a></li>
</ol>
<p>關於作者：<br><a href="http://huli.logdown.com/" target="_blank" rel="external">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Caffe & GoogLeNet，怎麼幫助機器人更好地辨識物體]]></title>
      <url>http://blog.techbridge.cc/2016/03/19/ros-caffe/</url>
      <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>這次要談的內容，是使用深度學習(Deep Learing)的模型來讓機器人做物體辨識。深度學習在這幾年來變得很火紅，相關的框架也相當多，這次之所以想談caffe，是因為已經有現成的方法可以將它應用到機器人上面。（有位台灣的開發者弄了一個叫做<a href="https://github.com/tzutalin/ros_caffe" target="_blank" rel="external">ros_caffe</a>的package來串接ROS(機器人作業系統)跟Caffe，可以將Caffe辨識的結果丟到一個ROS的topic，其他的node就可以自己取用。這使得機器人辨識物體的能力得以大幅增加）</p>
<h2 id="一點點幫助入門的細節"><a href="#一點點幫助入門的細節" class="headerlink" title="一點點幫助入門的細節"></a>一點點幫助入門的細節</h2><p>基本的安裝方法可以參考<a href="http://tzutalin.blogspot.tw/2015/06/setup-caffe.html" target="_blank" rel="external">這個連結</a>，假設已經裝成功，那至少就已經有基本的環境可以用(有一個caffe的資料夾被放在你安裝的路徑)，接下來需要下載<a href="https://github.com/BVLC/caffe/tree/master/models/bvlc_googlenet" target="_blank" rel="external">GoogLeNet的model</a>，只要用caffe/scripts資料夾裡的程式幫忙就行了:</p>
<p><code>$./scripts/download_model_binary.py ./models/bvlc_googlenet</code></p>
<p>上面這個指令會將GoogLeNet的model下載到caffe/models/bvlc_googlenet，假設已經下載好model，接下來就可以用一個小程式來跑跑看GoogLeNet了:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> 	</span><br><span class="line"><span class="comment"># Make sure that caffe is on the python path:</span></span><br><span class="line">caffe_root = <span class="string">'../'</span> <span class="comment"># this file is expected to be in &#123;caffe_root&#125;/examples</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, caffe_root + <span class="string">'python'</span>)</span><br><span class="line">sys.path.append(&amp;quot;/usr/lib/python2<span class="number">.7</span>/dist-packages/&amp;quot;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the right path to your model definition file, pretrained model weights,</span></span><br><span class="line"><span class="comment"># and the image you would like to classify.</span></span><br><span class="line">MODEL_FILE = <span class="string">'../models/bvlc_googlenet/deploy.prototxt'</span></span><br><span class="line">PRETRAINED = <span class="string">'../models/bvlc_googlenet/bvlc_googlenet.caffemodel'</span></span><br><span class="line">IMAGE_FILE = <span class="string">'images/cat.jpg'</span></span><br><span class="line"> </span><br><span class="line">caffe.set_mode_cpu()</span><br><span class="line">net = caffe.Classifier(MODEL_FILE, PRETRAINED,</span><br><span class="line">mean=np.load(caffe_root + <span class="string">'python/caffe/imagenet/ilsvrc_2012_mean.npy'</span>).mean(<span class="number">1</span>).mean(<span class="number">1</span>),</span><br><span class="line">channel_swap=(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">raw_scale=<span class="number">255</span>,</span><br><span class="line">image_dims=(<span class="number">256</span>, <span class="number">256</span>))</span><br><span class="line"> </span><br><span class="line">input_image = caffe.io.load_image(IMAGE_FILE)</span><br><span class="line">plt.imshow(input_image)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line">prediction = net.predict([input_image])</span><br><span class="line">plt.plot(prediction[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'predicted class:'</span>, prediction[<span class="number">0</span>].argmax()</span><br></pre></td></tr></table></figure>
<p>接下來只要執行(因為程式放在examples資料夾底下):</p>
<p><code>$python ./examples/googlenet_example.py</code></p>
<p>就可以看到一隻貓的影像，關掉影像之後就會看到貓的類別:</p>
<p><img src="/img/pojenlai/cat_class.png" alt="cat_class"></p>
<h2 id="串接ros-caffe"><a href="#串接ros-caffe" class="headerlink" title="串接ros_caffe"></a>串接ros_caffe</h2><p>如果想往下跟ros_caffe的串接可以參考<a href="http://www.artificialhumancompanions.com/integrating-ros-caffe-opencv-on-the-autonomous-deep-learning-robot/" target="_blank" rel="external">外國鄉民的文章</a>，裡面有完整而詳細的步驟。如果你已經安裝過caffe，可以參考<a href="https://github.com/tzutalin/ros_caffe/issues/1" target="_blank" rel="external">這個issue</a>。</p>
<p>需要注意的是，外國鄉民跑的只有global的結果，也就是一張影像中只有一個最顯著的物體會被辨識，如果要辨識一張影像中的各個物體，可能就要自己在中間串接一個負責做segmentation的node，再把各個切出來的區塊餵給ros_caffe來做辨識。</p>
<p>關於作者：<br><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何打造更好的科技新創 (Startup) 工作環境和組織文化？]]></title>
      <url>http://blog.techbridge.cc/2016/03/19/how-to-build-a-great-startup-culture/</url>
      <content type="html"><![CDATA[<p>最近剛好在<a href="http://www.zhihu.com/" target="_blank" rel="external">知乎</a>上看到一篇<a href="http://daily.zhihu.com/story/4264615" target="_blank" rel="external">矽谷新創公司文化和工作環境的文章</a> (內容主要還是以網路或科技新創公司為主)。這些公司雖然業務內容大不相同但還是有一些共通性。根據自己的經驗做一下翻譯和補充，期待未來台灣也能有更多世界一流的科技新創公司，提供人才更好的舞台和工作環境，大家一起加油啦！</p>
<p>第 0 步：找到對的人上車 (確保每位加入成員都能理解並認同公司價值觀和願景。打造優良的組織文化並不容易，但崩解可能只是一夕之間。最初 Airbnb 找第一號員工就花了約半年的時間！)</p>
<p>參考文件：<a href="http://36kr.com/p/216739.html" target="_blank" rel="external">Airbnb創辦人Brian Chesky談企業文化</a></p>
<ol>
<li>開放式辦公室，直接溝通，少開會。代碼勝於雄辯 (Code wins arguments.)</li>
<li>免費食物，提供工作餐點，也可以說故意延長工作時間 :P</li>
<li>使用蘋果電腦 (Mac) 或 Linux， 以及使用 Linux 的雲端伺服器 (Cloud Server)</li>
<li>擁抱開源軟體 (Open Source)，利用各種可用工具，注意力集中在核心產品</li>
<li>快速迭代 (Iterate)，A / B Testing，數據驅動思考 (Data Driven Thinking)</li>
<li>注重使用者體驗 (User Experience)，使用者利益大於獲利考慮</li>
<li>簡約設計，注重 MVP (最小可行) 的產品，敏捷開發</li>
<li>工程師文化，不惜代價找到最合適的人才，常舉辦內部 Hack Day。技術分享風氣濃厚，熱於學習新技術</li>
</ol>
<p>事實上，以上幾點科技新創 (Startup) 的常見文化和工作環境未必合適於每個組織中。能找到合適的夥伴加入團隊，一起打造適合的文化和價值觀才是關鍵。</p>
<p>參考文件：</p>
<ol>
<li><a href="http://blog.littlelin.info/posts/2014/05/04/what-makes-good-engineering-culture-1" target="_blank" rel="external">[翻譯] 是什麼造就了好的軟體工程文化？(上)</a></li>
<li><a href="http://blog.littlelin.info/posts/2014/09/21/what-makes-good-engineering-culture-2" target="_blank" rel="external">[翻譯] 是什麼造就了好的軟體工程文化？(下)</a></li>
</ol>
<p>關於作者：<br><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobiel 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; iOS/Android lover. Keep Shipping Cool Mobile App &amp; Web App.:)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[關於這個技術共筆部落格]]></title>
      <url>http://blog.techbridge.cc/2016/03/19/about/</url>
      <content type="html"><![CDATA[<p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等正體中文技術原創文章或國外好文翻譯分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robot, IoT, data analytics technology sharing.</p>
<ul>
<li>技術日報：<a href="http://www.techbridge.cc/" target="_blank" rel="external">http://www.techbridge.cc/</a></li>
<li>技術週刊：<a href="http://weekly.techbridge.cc/" target="_blank" rel="external">http://weekly.techbridge.cc/</a></li>
<li>技術共筆部落格：<a href="http://blog.techbridge.cc/">http://blog.techbridge.cc/</a></li>
<li>粉絲專頁：<a href="https://www.facebook.com/TechBridge.Fans/" target="_blank" rel="external">https://www.facebook.com/TechBridge.Fans/</a></li>
<li>電子郵件：<a href="mailto:techbridge.cc@gmail.com" target="_blank" rel="external">techbridge.cc@gmail.com</a></li>
</ul>
<h2 id="目前負責的-Curator（歡迎有興趣朋友跳坑加入策展人團隊-P）"><a href="#目前負責的-Curator（歡迎有興趣朋友跳坑加入策展人團隊-P）" class="headerlink" title="目前負責的 Curator（歡迎有興趣朋友跳坑加入策展人團隊:P）"></a>目前負責的 Curator（歡迎有興趣朋友跳坑加入策展人團隊:P）</h2><ol>
<li><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校</li>
<li><a href="http://blog.arvinh.info/about/" target="_blank" rel="external">@arvinh</a> 前端攻城獅，熱愛數據分析和資訊視覺化</li>
<li><a href="http://huli.logdown.com" target="_blank" rel="external">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</li>
<li><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
