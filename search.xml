<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[用DDS開發ROS 2.0]]></title>
      <url>http://blog.techbridge.cc/2016/04/15/ros-2-dds/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章想要向大家介紹ROS 2.0的底層實作概念，雖然比較不會有程式實作的討論，但我覺得這一塊的深度滿值得介紹的，因為使用ROS有好幾種層次:</p>
<p>1.使用ROS的各種工具來建立自己的應用<br>2.在開發上碰到一些問題，修改現成的package來滿足自己的需求<br>3.開發自己的演算法，發布自己的package給其他人使用<br>4.協助開發與維護ROS的核心</p>
<p>這篇文章要討論的議題已經落在第四個層次，所以對於一般的使用者來說，可能不太具有直接應用的價值，但如果對於ROS的底層實作有更深入的理解(知道他是怎麼開發出來的、有哪些限制、有哪些優點)，就可以在利用ROS撰寫自己的應用時，更能開發出效能最佳化的應用。</p>
<h2 id="為什麼要開發ROS-2-0"><a href="#為什麼要開發ROS-2-0" class="headerlink" title="為什麼要開發ROS 2.0?"></a>為什麼要開發ROS 2.0?</h2><p>事實上，如果ROS 1.0 已經足夠完美，那我們就沒有必要討論ROS 2.0。不過事情當然不是這樣，因為ROS 1.0在開發的時候，是圍繞著一隻機器人來開發的，雖然當初的設計已經讓ROS變得很有彈性，可以被應用在各式各樣的機器人上，但是隨著使用者越來越多，超乎開發者想像的使用情境也越來越多。</p>
<p>也就是說，如果開發者們不積極地開始開發下一代的ROS，遲早會無法滿足越來越複雜而多樣化的需求。對於這些使用情境的具體描述，可以參考<a href="http://po-jen.github.io/design/articles/why_ros2.html#section-1" target="_blank" rel="external">這裡</a>。</p>
<h2 id="開發ROS系統需要實現的模塊"><a href="#開發ROS系統需要實現的模塊" class="headerlink" title="開發ROS系統需要實現的模塊"></a>開發ROS系統需要實現的模塊</h2><p>首先來談論一下建立整個系統上，需要考慮的幾個重點:</p>
<ul>
<li>Discovery功能</li>
<li>Publisher-Subscriber功能</li>
<li>Service 與 Action功能</li>
</ul>
<p>Discovery功能的意義是，只要有新的node啟動，就能在整個ROS node的網路中被看見(概念很像是我打開手機的wifi熱點分享，其他裝置就應該要可以發現有這個wifi熱點)。</p>
<p>接下來的Publisher-Subscriber功能、Service功能跟Action功能其實就是ROS使用者熟悉的Topic、Service跟Actionlib啦，本質上這幾種功能在處理的都是node之間的溝通(也就是程式之間的溝通，大家可以想像要讓一隻機器人正常運作，電腦上需要運行的程式一定是很多個，而且需要彼此溝通，所以底層的溝通機制需要有人來實作，不然就是…想開發機器人程式的你得自己實作)。如果你不太確定自己知不知道我在說什麼，可以看看這一篇<a href="https://pojenlai.wordpress.com/2012/11/03/ros-topic-service-and-actionlib/" target="_blank" rel="external">區分Topic、Service跟Actionlib的文章</a>。</p>
<h2 id="DDS的系統層概念"><a href="#DDS的系統層概念" class="headerlink" title="DDS的系統層概念"></a>DDS的系統層概念</h2><p>想要實作上面這些功能，DDS並不是唯一的選擇，但是，OSRF(Open Source Robotic Foundation)的開發者經過嘗試之後，覺得這是最好的開發選項。細節理由可以看延伸閱讀的第3篇文章，這部分已經有中文翻譯了。</p>
<p><img src="/img/pojenlai/api_levels.png" alt="api_levels"></p>
<p>從上面這張圖可以清楚地看出，使用者所需要接觸到的只有最上面的兩層。使用者自己寫的code就屬於Userland Code，而使用者自己寫的code中呼叫到的ROS API (例如ros::init())就屬於ROS client library API，而DDS的API則是在更底層被ROS client library API所使用。</p>
<p>有趣的地方是，為了保持彈性，OSRF的開發者們希望使用者可以自己選擇底層使用的是哪一個版本的DDS (DDS像是一種標準，所以可以有不同公司提供自己的實作版本)。</p>
<h2 id="一點細節的延伸"><a href="#一點細節的延伸" class="headerlink" title="一點細節的延伸"></a>一點細節的延伸</h2><p>上面討論的都是概念的理解，對於技術有興趣的你想必沒辦法接受，所以就讓我們來看一點技術細節吧!</p>
<p>我們還是一樣先站在開發者的角度，最基本我們需要提供的工具就是Node初始化的函式對吧，這個函式的長相就像:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Node::Node(<span class="built_in">std</span>::<span class="built_in">string</span> name): running_(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*----------------------親切的中文註解來囉!!!----------------------*/</span></span><br><span class="line">	nodes_.push_back(<span class="keyword">this</span>);</span><br><span class="line">	subscription_iterator_ = subscriptions_.end();</span><br><span class="line">	name_ = name;</span><br><span class="line">	<span class="comment">//取得了DDS的DomainParticipantFactory的instance，很像是一個node產生器的感覺</span></span><br><span class="line">	dpf_ = DDS::DomainParticipantFactory::get_instance();</span><br><span class="line">	checkHandle(dpf_.in(), <span class="string">"DDS::DomainParticipantFactory::get_instance"</span>);</span><br><span class="line">	DDS::DomainId_t domain = DDS::DOMAIN_ID_DEFAULT;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//實際產生一個participant，應該就是一個node</span></span><br><span class="line">	participant_ = create_participant( domain, PARTICIPANT_QOS_DEFAULT, NULL,DDS::STATUS_MASK_NONE);</span><br><span class="line">	checkHandle(participant_.in(), <span class="string">"DDS::DomainParticipantFactory::create_participant"</span>);</span><br><span class="line">	<span class="comment">/*----------------------看到這裡就好囉!!!----------------------*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the default QoS for Topics</span></span><br><span class="line">	DDS::ReturnCode_t status = participant_get_default_topic_qos(default_topic_qos_);</span><br><span class="line">	checkStatus(status, <span class="string">"DDS::DomainParticipant::get_default_topic_qos"</span>);</span><br><span class="line">	default_topic_qos_.reliability.kind = DDS::BEST_EFFORT_RELIABILITY_QOS;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the default QoS for Publishers</span></span><br><span class="line">	status = participant_get_default_publisher_qos(default_publisher_qos_);</span><br><span class="line">	checkStatus(status, <span class="string">"DDS::DomainParticipant::get_default_publisher_qos"</span>);</span><br><span class="line">	default_publisher_qos_.partition.name.length(<span class="number">1</span>);</span><br><span class="line">	default_publisher_qos_.partition.name[<span class="number">0</span>] = <span class="string">"ros_partition"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the default QoS for Subscribers</span></span><br><span class="line">	status = participant_get_default_subscriber_qos(default_subscriber_qos_);</span><br><span class="line">	checkStatus(status, <span class="string">"DDS::DomainParticipant::get_default_publisher_qos"</span>);</span><br><span class="line">	default_subscriber_qos_.partition.name.length(<span class="number">1</span>);</span><br><span class="line">	default_subscriber_qos_.partition.name[<span class="number">0</span>] = <span class="string">"ros_partition"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create a waitset for spin</span></span><br><span class="line">	waitset_ = new DDS::WaitSet();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a parameter server for this node</span></span><br><span class="line">	create_parameter_server(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家先不要嚇到，一下有太多細節本來就不可能看懂，大家只需要看我用註解標記起來的區域，體驗一下什麼叫做ROS client library API呼叫DDS API的感覺就好。</p>
<p>那對於一個使用者來說，假設我今天要啟動一隻機器人，那就需要呼叫建立node的函式，看起來就像:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TurtleApp(<span class="keyword">int</span>&amp; argc, <span class="keyword">char</span>** argv): QApplication(argc, argv)</span><br><span class="line">&#123;</span><br><span class="line">	rclcpp::init(argc, argv);</span><br><span class="line">	nh_ = rclcpp::create_node(<span class="string">"turtlesim"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你一定覺得奇怪，rclcpp::create_node()跟上面我講的Node::Node()建構子根本接不起來啊? 所以這邊就要補上一點點程式碼，想必你就懂了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rclcpp::init(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (globally_initialized)</span><br><span class="line">	&#123;</span><br><span class="line">		throw AlreadyInitializedError();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Register a signal handler so DDS doesn not just sit there... */</span></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGINT, Node::static_signal_handler) == SIG_ERR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"An error occurred while setting a signal handler.\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	globally_initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node::Ptr rclcpp::create_node(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">&#123;</span><br><span class="line">	return Node::Ptr(new Node(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>OK!簡介就到這邊啦，如果對於實作細節有興趣深入的讀者，不妨去看看ROS 2.0的github repo，詳細的程式碼全部都是開源的，所以可以從中學習開發的細節。</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p>1.<a href="http://po-jen.github.io/design/articles/why_ros2.html" target="_blank" rel="external">為什麼要開發ROS 2.0?</a><br>2.<a href="http://po-jen.github.io/design/articles/ros_with_zeromq.html" target="_blank" rel="external">使用ZeroMQ跟相關的函式庫來開發ROS</a><br>3.<a href="http://po-jen.github.io/design/articles/ros_on_dds.html" target="_blank" rel="external">使用DDS來開發ROS</a> (仍在趕工中，歡迎開issue催促翻譯者QQ)<br>4.<a href="https://github.com/ros2/ros2/wiki" target="_blank" rel="external">ROS 2.0 wiki</a><br>5.<a href="https://github.com/osrf/ros_dds/tree/master/prototype" target="_blank" rel="external">ROS DDS Prototype (Github Repo)</a></p>
<p>關於作者：<br><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一看就懂的 React ES5、ES6+ 常見用法對照表]]></title>
      <url>http://blog.techbridge.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/</url>
      <content type="html"><![CDATA[<p><img src="/img/kdchang/react-es6.jpg" alt="一看就懂的 React ES5、ES6+ 常見用法對照表"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> 是 Facebook 推出的開源 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a> Library。自從 React 正式開源後，React 生態系開始蓬勃發展。事實上，透過學習 React 生態系（ecosystem）的過程中，可以讓我們順便學習現代化 Web 開發的重要觀念（例如：ES6、<a href="https://github.com/webpack/webpack" target="_blank" rel="external">Webpack</a>、<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>、模組化等），成為更好的開發者。雖然 ES6（ECMAScript2015）、ES7 是未來趨勢（本文將 ES6、ES7 稱為 ES6+），然而目前在網路上有許多的學習資源仍是以 ES5 為主，導致讀者在學習上遇到一些坑洞和迷惑（本文假設讀者對於 React 已經有些基本認識，若你對於 React 尚不熟悉，建議先行<a href="https://facebook.github.io/react/" target="_blank" rel="external">閱讀官方文件</a>和<a href="https://scotch.io/tutorials/learning-react-getting-started-and-concepts" target="_blank" rel="external">本篇入門教學</a>）。因此本文希望透過整理在 React 中 ES5、ES6+ 常見用法對照表，讓讀者們可以在實現功能時（尤其在 <a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>）可以更清楚兩者的差異，無痛轉移到 ES6+。 </p>
<h2 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h2><ol>
<li>Modules</li>
<li>Classes</li>
<li>Method definition</li>
<li>Property initializers</li>
<li>State</li>
<li>Arrow functions</li>
<li>Dynamic property names &amp; template strings</li>
<li>Destructuring &amp; spread attributes</li>
<li>Mixins</li>
<li>Default Parameters</li>
</ol>
<h2 id="1-Modules"><a href="#1-Modules" class="headerlink" title="1. Modules"></a>1. Modules</h2><p>隨著 Web 技術的進展，模組化開發已經成為一個重要課題。關於 JavaScript 模組化我們這邊不詳述，建議讀者參考 <a href="http://huangxuan.me/js-module-7day/#/" target="_blank" rel="external">這份投影片</a> 和 <a href="http://justineo.github.io/singles/writing-modular-js/" target="_blank" rel="external">這篇文章</a>。</p>
<p>ES5 若使用 CommonJS 標準，一般使用 <code>require()</code> 用法引入模組：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> MyComponent = <span class="built_in">require</span>(<span class="string">'./MyComponent'</span>);</span><br></pre></td></tr></table></figure>
<p>輸出則是使用 <code>module.exports</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = MyComponent;</span><br></pre></td></tr></table></figure>
<p>ES6+ <code>import</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</span><br></pre></td></tr></table></figure>
<p>輸出則是使用 <code>export default</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Compoent</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Classes"><a href="#2-Classes" class="headerlink" title="2. Classes"></a>2. Classes</h2><p>在 React 中元件（Component）是組成視覺頁面的基礎。在 ES5 中我們使用 <code>React.createClass()</code> 來建立 Component，而在 ES6+ 則是用 <a href="https://babeljs.io/docs/learn-es2015/#classes" target="_blank" rel="external">Classes</a> 繼承 <code>React.Component</code> 來建立 Component。若是有寫過 Java 等物件導向語言（OOP）的讀者應該對於這種寫法比較不陌生，不過要注意的是 JavaScript 仍是原型繼承類型的物件導向程式語言，只是使用 <code>Classes</code> 讓物件導向使用上更加直觀。對於選擇 <code>class</code> 使用上還有疑惑的讀者建議可以閱讀 <a href="https://toddmotto.com/react-create-class-versus-component/" target="_blank" rel="external">React.createClass versus extends React.Component</a> 這篇文章。</p>
<p>ES5 <code>React.createClass()</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.description&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    	);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Photo</span> /&gt;</span>, document.getElementById('main'));</span></span><br></pre></td></tr></table></figure>
<p>ES6+ <code>class</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.description&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="tag">&lt;<span class="name">Photo</span> /&gt;</span>, document.getElementById('main'));</span></span><br></pre></td></tr></table></figure>
<p>在 ES5 我們會在 <code>componentWillMount</code> 生命週期定義希望在 <code>render</code> 前執行，且只會執行一次的任務：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 則是定義在 <code>constructor</code> 建構子中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 原本在 componentWillMount 操作的動作可以放在這</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Method-definition"><a href="#3-Method-definition" class="headerlink" title="3. Method definition"></a>3. Method definition</h2><p>在 ES6 中我們使用 <code>Method</code> 可以忽略 <code>function</code> 和 <code>,</code>，使用上更為簡潔！ES5 <code>React.createClass()</code> 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6+ class 用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(e) &#123;&#125;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Property-initializers"><a href="#4-Property-initializers" class="headerlink" title="4. Property initializers"></a>4. Property initializers</h2><p>Component 屬性值是資料傳遞重要的元素，在 ES5 中我們使用 <code>propTypes</code> 和  <code>getDefaultProps</code> 來定義屬性（props）的預設值和型別：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      checked: <span class="literal">false</span>,</span><br><span class="line">      maxLength: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  propTypes: &#123;</span><br><span class="line">    checked: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLength: React.PropTypes.number.isRequired</span><br><span class="line">  &#125;,</span><br><span class="line">  render: fucntion() &#123;</span><br><span class="line">  	<span class="keyword">return</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 中我們則是參考 <a href="https://github.com/jeffmo/es-class-fields-and-static-properties" target="_blank" rel="external">ES7 property initializers</a> 使用 <code>class</code> 中的靜態屬性（static properties）來定義：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    checked: <span class="literal">false</span>,</span><br><span class="line">    maxLength: <span class="number">10</span>,</span><br><span class="line">  &#125;; <span class="comment">// 注意有分號</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    checked: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLength: React.PropTypes.number.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">  	<span class="keyword">return</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6+ 另外一種寫法，可以留意一下，主要是看各團隊喜好和規範，選擇合適的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Todo.defaultProps = &#123;</span><br><span class="line">    checked: false,</span><br><span class="line">    maxLength: 10,</span><br><span class="line">&#125;;</span><br><span class="line">Todo.propTypes = &#123;</span><br><span class="line">    checked: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLength: React.PropTypes.number.isRequired,</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-State"><a href="#5-State" class="headerlink" title="5. State"></a>5. State</h2><p>在 React 中 <code>Props</code> 和 <code>State</code> 是資料流傳遞的重要元素，不同的是 <code>state</code> 可更動，可以去執行一些運算。在 ES5 中我們使用 <code>getInitialState</code> 去初始化 <code>state</code>： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            maxLength: <span class="keyword">this</span>.props.maxLength,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 中我們初始化 <code>state</code> 有兩種寫法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        maxLength: <span class="keyword">this</span>.props.maxLength,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一種寫法，使用在建構式初始化。比較推薦使用這種方式，方便做一些運算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            maxLength: <span class="keyword">this</span>.props.maxLength,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Arrow-functions"><a href="#6-Arrow-functions" class="headerlink" title="6. Arrow functions"></a>6. Arrow functions</h2><p>在講 <code>Arrow functions</code> 之前，我們先聊聊在 React 中 <code>this</code> 和它所代表的 <code>context</code>。在 ES5 中，我們使用 <code>React.createClass()</code> 來建立 Component，而在 <code>React.createClass()</code> 下，預設幫你綁定好 <code>method</code> 的 <code>this</code>，你毋須自行綁定。所以你可以看到像是下面的例子，<code>callback function</code> handleButtonClick 中的  <code>this</code> 是指到 component 的實例（instance），而非觸發事件的物件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TodoBtn = React.createClass(&#123;</span><br><span class="line">    handleButtonClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 此 this 指到 component 的實例（instance），而非 button</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick&#125;</span>&gt;</span>&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然而自動綁定這種方式反而會讓人容易誤解，所以在 ES6+ 推薦使用 <code>bind</code> 綁定 <code>this</code> 或使用 <code>Arrow functions</code>（它會绑定當前 <code>scope</code> 的 <code>this context</code>）兩種方式，你可以參考下面例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    handleButtonClick(e)&#123;</span><br><span class="line">        <span class="comment">// 確認綁定 this 指到 component instance</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;toggle: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 這邊可以用 this.handleButtonClick.bind(this) 手動綁定或是 Arrow functions () =&gt; &#123;&#125; 用法</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick.bind(this)&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span> &#123;this.handleButtonClick(e)&#125; &#125;&gt;&#123;this.props.label&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Arrow functions</code> 雖然一開始看起來有點怪異，但其實觀念很簡單：一個簡化的函數。函數基本上就是參數（不一定要有參數）、表達式、回傳值（也可能是回傳 undefined）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Arrow functions 的一些例子</span><br><span class="line">()=&gt;7</span><br><span class="line">e=&gt;e+2</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    alert(&apos;XD&apos;);</span><br><span class="line">&#125;</span><br><span class="line">(a,b)=&gt;a+b</span><br><span class="line">e=&gt;&#123;</span><br><span class="line">    if (e == 2)&#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return 100/e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不過要注意的是無論是 <code>bind</code> 或是 <code>Arrow functions</code>，每次執行回傳都是指到一個新的函數，若需要再調用到這個函數，請記得先把它存起來：</p>
<p>錯誤用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        Btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidmount()&#123;</span><br><span class="line">        Btn.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused(event)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正確用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoBtn</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.handleButtonClick = <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        Btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidmount()&#123;</span><br><span class="line">        Btn.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleButtonClick);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多 Arrows and Lexical This 特性可以<a href="https://babeljs.io/docs/learn-es2015/#arrows" target="_blank" rel="external">參考這個文件</a>。</p>
<h2 id="7-Dynamic-property-names-amp-template-strings"><a href="#7-Dynamic-property-names-amp-template-strings" class="headerlink" title="7. Dynamic property names &amp; template strings"></a>7. Dynamic property names &amp; template strings</h2><p>以前在 ES5 我們要動態設定屬性名稱時，往往需要多寫幾行程式碼才能達到目標：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Todo = React.createClass(&#123;</span><br><span class="line">  onChange: <span class="function"><span class="keyword">function</span>(<span class="params">inputName, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stateToSet = &#123;&#125;;</span><br><span class="line">    stateToSet[inputName + <span class="string">'Value'</span>] = e.target.value;</span><br><span class="line">    <span class="keyword">this</span>.setState(stateToSet);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但在 ES6+中，透過 <a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">enhancements to object literals</a> 和 <a href="https://babeljs.io/docs/learn-es2015/#template-strings" target="_blank" rel="external">template strings</a> 可以輕鬆完成動態設定屬性名稱的任務：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Todo extends React.Component &#123;</span><br><span class="line">  onChange(inputName, e) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [`$&#123;inputName&#125;Value`]: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Template Strings 是一種語法糖（syntactic sugar），方便我們組織字串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interpolate variable bindings</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span> \\ Hello Bob, how are you today?</span><br></pre></td></tr></table></figure>
<h2 id="8-Destructuring-amp-spread-attributes"><a href="#8-Destructuring-amp-spread-attributes" class="headerlink" title="8. Destructuring &amp; spread attributes"></a>8. Destructuring &amp; spread attributes</h2><p>在 React 的 Component 中，父元件利用 <code>props</code> 來傳遞資料到子元件是常見作法，然而我們有時會希望只傳遞部分資料，此時 ES6+ 中的 <a href="https://babeljs.io/docs/learn-es2015/#destructuring" target="_blank" rel="external">Destructuring</a> 和 <a href="https://facebook.github.io/react/docs/jsx-spread.html" target="_blank" rel="external">JSX 的 Spread Attributes
</a> 就可以幫我們達到目標：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> &#123;</span><br><span class="line">      className,</span><br><span class="line">      ...others,  <span class="comment">// contains all properties of this.props except for className</span></span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TodoList</span> &#123;<span class="attr">...others</span>&#125; /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoadMoreClick&#125;</span>&gt;</span>Load more<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但使用上要注意的是若是有重複的屬性值則以後來覆蓋，下面的例子中若 <code>...this.props</code>，有 <code>className</code>，則被後來的 <code>main</code> 所覆蓋：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &#123;...this.props&#125; className=<span class="string">"main"</span>&gt;</span><br><span class="line">  …</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>而 <code>Destructuring</code> 也可以用在簡化 <code>Module</code> 的引入上，這邊我們先用 ES5 中引入方式來看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</span><br><span class="line"><span class="keyword">var</span> Component = React.component;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</span><br></pre></td></tr></table></figure>
<p>在 ES6+ 則可以直接使用 <code>Destructuring</code> 來引入模組中的元件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">	View,</span><br><span class="line">	Component,</span><br><span class="line">	Image</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</span><br></pre></td></tr></table></figure>
<h2 id="9-Mixins"><a href="#9-Mixins" class="headerlink" title="9. Mixins"></a>9. Mixins</h2><p>在 ES5 中，我們可以使用 <code>Mixins</code> 的方式去讓不同的 Component 共用相似的功能，重用我們的程式碼：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但由於官方不打算在 ES6+ 中繼續推行 <code>Mixins</code>，若還是希望使用，可以參考看看<a href="https://www.npmjs.com/package/es6-class-mixin" target="_blank" rel="external">第三方套件</a>或是<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" target="_blank" rel="external">這個文件的用法</a>。</p>
<h2 id="10-Default-Parameters"><a href="#10-Default-Parameters" class="headerlink" title="10. Default Parameters"></a>10. Default Parameters</h2><p>以前 ES5 我們函數要使用預設值需要這樣使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span> (<span class="params">height, color</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;  </span><br><span class="line">    <span class="keyword">var</span> color = color || <span class="string">'red'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在 ES6+ 的函數可以支援預設值，讓程式碼更為簡潔：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height = 50, color = 'red'</span>) </span>&#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以上就是 React ES5、ES6+常見用法對照表，能看到這邊的你應該已經對於 React ES5、ES6 使用上有些認識，先給自己一些掌聲吧！確實從 ES6 開始，JavaScript 和以前我們看到的 JavaScript 有些不同，增加了許多新的特性，有些讀者甚至會很懷疑說這真的是 JavaScript 嗎？ES6 的用法對於初學者來說可能會需要寫一點時間吸收，下面我幫大家準備了延伸閱讀，方便大家進一步參考學習。接下來我們也會有一系列從零開始學 React 的文章來帶大家由淺入深學習 ReactJS 生態系，運用 JavaScript 打造跨平台應用程式。筆者才書學淺，若有疏漏歡迎大家一起交流討論：）</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8" target="_blank" rel="external">React/React Native 的ES5 ES6写法对照表</a></li>
<li><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">React on ES6+</a></li>
<li><a href="http://www.ghugo.com/react-native-es6/" target="_blank" rel="external">react native 中es6语法解析</a> </li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">Learn ES2015</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a></li>
<li><a href="https://facebook.github.io/react/index.html" target="_blank" rel="external">React官方網站</a></li>
<li><a href="http://fraserxu.me/intro-to-react/" target="_blank" rel="external">React INTRO TO REACT.JS</a></li>
<li><a href="https://toddmotto.com/react-create-class-versus-component/" target="_blank" rel="external">React.createClass versus extends React.Component</a></li>
<li><a href="https://github.com/lzbSun/react-native-coding-style" target="_blank" rel="external">react-native-coding-style</a></li>
<li><a href="https://github.com/airbnb/javascript/tree/master/react" target="_blank" rel="external">Airbnb React/JSX Style Guide</a></li>
</ol>
<p>關於作者：<br><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobile 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; iOS/Android lover. Keep Shipping Cool Mobile App &amp; Web App.:)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Browser Rendering Optimization]]></title>
      <url>http://blog.techbridge.cc/2016/04/02/Browser-Rendering-Optimization/</url>
      <content type="html"><![CDATA[<blockquote>
<p>“My name is Barry Allen, and I’m the fastest man alive …”<br>“Wait..reverse flash is faster then you, zoom is faster than you..”<br><a id="more"></a></p>
</blockquote>
<p>今天來談談Browser Rendering Optimisation。</p>
<p>相信大家小時候都好奇過早期的電影、卡通或動畫，是怎麼樣製作出來的，而我們也都知道基本上就是一連串的<code>畫面</code>以非常快速的方式做切換，矇騙你的視覺讓你感受到是連續的<code>影片</code>，而Browser其實也是類似的做法，當取得Server的回應後，瀏覽器便把接收到的HTML畫出來，而每當你的網頁有所變化時，Browser就會再依據其邏輯將網頁重新渲染一遍，也因此才能看到這麼多漂亮的效果。</p>
<p>而所謂browser rendering optimization就是要讓渲染的過程能夠更快速、更順暢，讓你的網頁畫面如夢似幻、細緻耀眼。</p>
<p>要做到這件事情，就必須提及FPS(Frames per Second)，顧名思義就是每秒畫幾個Frames，一般影片大概是<a href="https://en.wikipedia.org/wiki/Frame_rate" target="_blank" rel="external">30fps</a>，而多數螢幕畫面的更新頻率是60Hz，因此若我們能將fps極致提升到60fps，理當能有非常棒的畫面呈現！</p>
<p>知道目標後，let’s do some math…<br><code>60fps = 60 frames per second = 60 frames every 1000ms</code><br>好的從我們優異的數學能力下得知，要達到60fps，我們繪製一個frames的時間必須在16.6666…ms左右(1000/60)</p>
<p>ok，那要怎麼知道自己的網頁每個frames花了多少時間繪製？拜Google大神所賜，只要打開Chrome的devTool，切換到Timeline的tab，就可以很容易的知道網頁在browser上的render時間。讓我們用畫面超級old school的pchome拍賣來Demo一下：</p>
<p><img src="/img/arvinh/googleDevTool-pchome.png" alt="Devtool-timeline(點圖放大)" title="DevTool-timeline"></p>
<p>先別被圖中五顏六色的區塊嚇到，在我們說明這Tool該如何使用之前，必須先瞭解Browser的Render過程，以及這圖片中每個顏色所代表的意義。</p>
<p>接觸過HTML的人一定都知道所謂的DOM Tree，Browser會解析HTML並轉換成DOM Tree做操作，但知道<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en" target="_blank" rel="external">Render Tree</a>的人可能就不多了，Render tree由DOM tree與CSS結合產生，Browser就是依照Render Tree來決定該在畫面上呈現什麼東西。若你今天在某個div的css上加上<code>display: none</code>，那這個div就不會再Render tree上呈現。</p>
<p><img src="/img/arvinh/RenderTree.png" alt="Render Tree (source from google)"></p>
<p>既然Render的過程也是一棵Tree，有點概念的人可能會想：每次style改變或是我更動DOM的位置時，這棵Tree也就會變動了吧？<br>沒錯！在整個Browser的Render過程中，就是會不斷去recalculating style、layout的關係，來建構這棵樹。</p>
<p>當然Browser的渲染過程不止這些，還必須載入js, css, web api等等的資源，因此有所謂的Rendering Pipeline</p>
<p><img src="/img/arvinh/render_pipeline.png" alt="Render Pipeline (source from google)"><br>從圖上可以發現其順序為：</p>
<ol>
<li>Javascript: 載入與執行JS/CSS</li>
<li>Style: 根據js與css計算style</li>
<li>Layout: 當style套入元素時，瀏覽器要檢查是否會影響到整個畫面的排列，並進行排列</li>
<li>Paint: 排列後有更動到的元素需要重新繪製（第一次載入的話當然是全部繪製）</li>
<li>Composite: 最後就是將所有元素重新合成回來（重新繪製的元素與原本的元素）</li>
</ol>
<p>實際上並非每次的前端更動都會執行這五個步驟，若你只有切換顏色、圖片等不影響版面配置的動作，browser會跳過Layout，直接進行Paint；或著你捲動網頁、css的動畫效果，這類操作則會跳過style與layout，直接進行Composite。</p>
<p>接下來我們回到Timeline這個tool。</p>
<p><img src="/img/arvinh/Timeline2.png" alt="Timeline record"><br>你可以直接在你想觀察的網頁打開Timeline，並重新整理，他就會自行錄製；或是你可以在你想觀察的操作步驟進行前（ex. 滑動頁面、打開menu bar等等）按下錄製。</p>
<p><img src="/img/arvinh/Timeline3.png" alt="Timeline finish"></p>
<p>接著在你覺得適合的地方（通常就是步驟執行完後）按下Finish。</p>
<p><img src="/img/arvinh/Timeline1.png" alt="Timeline result"></p>
<p>基本上就能得到下列的Timeline結果。<br>從這張圖片可以清楚看到每個frame花了多少時間，在Render pipeline中發生了哪些事情，值得注意的是，圖片右上角有個紅色小三角形，若你的frame中有這個標記，就代表Chrome認為這段frame有可以改善的部分。大家不妨到自己的網頁打開Timeline，看看有多少東西需要改進XD</p>
<p>在認識了工具後，總是要實際操作一遍才會有感受，這邊以三種角度來進行Optimization。</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>一般來說，前端工程師常常會利用<code>setTimeout</code>或是<code>setInterval</code>來製作一些動畫效果，你可能會寫下面這樣的code:</p>
<p><a href="https://jsbin.com/xuconawipi/5/edit?html,js,output" target="_blank" rel="external">example setInterval</a></p>
<figure class="highlight javascript"><figcaption><span>setInterval.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;time: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">timer</span>) </span>&#123; </span><br><span class="line">  timer.time = timer.time+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">"#counter"</span>).innerHTML = timer.time;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(counter.bind(<span class="literal">null</span>,timer), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>或著是</p>
<p><a href="https://jsbin.com/yocokorelu/edit?html,js,output" target="_blank" rel="external">example setTimeout</a><br><figure class="highlight javascript"><figcaption><span>setTimeout.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;time: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">timer</span>) </span>&#123; </span><br><span class="line">	setTimeout(counter.bind(<span class="literal">null</span>,timer), <span class="number">1000</span>);</span><br><span class="line">	timer.time = timer.time+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">document</span>.querySelector(<span class="string">"#counter"</span>).innerHTML = timer.time;</span><br><span class="line">&#125;</span><br><span class="line">counter(timer);</span><br></pre></td></tr></table></figure></p>
<p>兩者都可以讓你達到同樣的效果，但是setTimeout跟setInterval對Browser來說都有個主要缺點，就是他<strong><span style="color:red; font-style: italic;">想執行時就會執行，而不會依據你的Browser狀況<span></span></span></strong>；另外當你切換到別的Tab時，setTimeout還會繼續Render。（理論上user看不到畫面，Browser就可以不用執行，以節省效能）<br><em><span style="color:rgba(228, 85, 85, 0.81); font-style: italic;">不過現在許多瀏覽器都已經利用某些方式讓setTimeout在不需要Render時暫停工作。</span></em></p>
<p>除了setTimeout與setInterval外，我們其實還有另一個選擇 <span style="color:red;"><code>requestAnimationFrame</code></span></p>
<p>假設我們有個Draw的動畫function，用setTimeout是這樣實作：<br><figure class="highlight javascript"><figcaption><span>draw.js	</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(draw, <span class="number">16</span>); <span class="comment">// 16ms per frame!</span></span><br><span class="line">    <span class="comment">// Drawing</span></span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure></p>
<p>若是用requestAnimationFrame：<br><figure class="highlight javascript"><figcaption><span>draw-RAF.js	</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// Drawing</span></span><br><span class="line">	requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(draw);</span><br></pre></td></tr></table></figure></p>
<p>就這麼簡單，用了<span style="color:red;"><code>requestAnimationFrame</code></span>之後，Browser就會綜合考量javascript所產生的動畫，一起刷新螢幕，並在動畫不在viewport時，暫停工作，以節省資源。</p>
<p>當然你會想說，那如果我想控制animation的timing怎麼辦？以前面的counter例子來看，你可以這樣做：</p>
<p><a href="https://jsbin.com/qerude/edit?html,js,output" target="_blank" rel="external">example reqeustAnimationFrame</a><br><figure class="highlight javascript"><figcaption><span>RAF_timeer		</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;time: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">timer</span>) </span>&#123; </span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    requestAnimationFrame(counter.bind(<span class="literal">null</span>, timer));</span><br><span class="line">    timer.time = timer.time+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"#counter"</span>).innerHTML = timer.time;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">counter(timer);</span><br></pre></td></tr></table></figure></p>
<h2 id="Style-amp-Layout"><a href="#Style-amp-Layout" class="headerlink" title="Style &amp; Layout"></a>Style &amp; Layout</h2><p>除了JS外，在頁面上操作畫面大多免不了觸發<code>Style</code> &amp; <code>Layout</code>這兩個Render Pipeline的步驟。既然免不了這些步驟，我們能做的就是盡量<strong>減少</strong>這些步驟的產生，大家可以到這裡（<a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html" target="_blank" rel="external">How (not) to trigger a layout in WebKit</a>）看看在有哪些操作我們要盡量減少。</p>
<p>當然，光說不練感受不到差別，讓我們來練習一個例子：</p>
<p><a href="https://jsbin.com/yesika/edit?html,css,js,output" target="_blank" rel="external">example Layout trigger</a><br><figure class="highlight javascript"><figcaption><span>befor-optimization.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// noprotect</span></span><br><span class="line">  <span class="keyword">var</span> sizer = <span class="built_in">document</span>.querySelector(<span class="string">'.sizer'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.set-size'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.article .article-block'</span>);</span><br><span class="line">    <span class="keyword">var</span> i = ps.length;</span><br><span class="line">    <span class="keyword">var</span> size;</span><br><span class="line">    <span class="keyword">var</span> finalHeight = sizer.offsetHeight;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      ps[i].style.height = finalHeight + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p><a href="https://jsbin.com/wukuzi/2/edit?html,css,js,output" target="_blank" rel="external">example Less Layout trigger</a><br><figure class="highlight javascript"><figcaption><span>after-optimization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// noprotect</span></span><br><span class="line">  <span class="keyword">var</span> sizer = <span class="built_in">document</span>.querySelector(<span class="string">'.sizer'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.set-size'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.article .article-block'</span>);</span><br><span class="line">    <span class="keyword">var</span> i = ps.length;</span><br><span class="line">    <span class="keyword">var</span> size;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      finalHeight = sizer.offsetHeight;</span><br><span class="line">      ps[i].style.height = finalHeight + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>仔細看就會發現其實只有一行code有變動，效果卻差很多！當你在操作類似DOM物件的時候可以參考上述的網站，避免不必要的re-layout動作。</p>
<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><p>在一個網頁的頁面當中，實際上並非是平面的，通常會由許多<code>Layer</code>所組成，而在Browser rendering pipeline的最後一個步驟<code>Composite</code>中，就是負責將這些Layer組合成完整的頁面。</p>
<p>我們這次以最近Live直播統一獅頗為熱門的Yahoo首頁為例子，依照先前的方式打開Dev tool中的Timeline，選取其中一段frame後，點選下方的<code>Layers</code>標籤，應該就可以看到類似下面的圖：<br><img src="/img/arvinh/layer.png" alt="Composite Layers"><br><img src="/img/arvinh/compositeLayers.png" alt="Composite Layers (而在Timeline的工具中，旁邊還能讓你拖拉旋轉，方便查看各個Layer的狀況。)"></p>
<p>可以發現yahoo首頁也是由許多層Layer所組成。</p>
<p>眼尖的讀者可能會發現為什麼頁面中只有一個區塊是綠色的？這就是這小節的重點了，在Composite的過程中，只有需要重新Style與Layout的Layer才需要重繪，而這些需要重繪的Layer就會被標註成綠色；以yahoo首頁為例，綠色的那條是影音列表，理當會不斷變動，因此會被Highlight為綠色。</p>
<p>那為什麼我們需要針對這個步驟做Optimize呢？因為假如在同一層layer中，你其實只有某一個div需要re-layout，但由於是在同一個Layer，會變成整個Layer都需要重新繪製，如此一來就會增加不必要的負擔。</p>
<p>因此我們可以在你確定會需要重繪制的div中，加入<code>will-change: transform;</code>這個屬性，告訴browser說，“欸~我知道我可能會變動喔，請不要把大家跟我視為一樣的”，這樣就能解決上述的問題。</p>
<p>大家不妨打開自己的網站，利用Chrome的Timeline玩看看，提升頁面的渲染效率，讓我們一起追求60ps的極致快感吧！</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html" target="_blank" rel="external">How not to trigger layout in webkit</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/?hl=en" target="_blank" rel="external">Google Web Fundamentals</a></li>
<li><a href="http://www.html5rocks.com/zh/tutorials/speed/layers/" target="_blank" rel="external">Accelerated Rendering in Chrome</a></li>
</ol>
<p>關於作者：<br><a href="http://blog.arvinh.info/about/" target="_blank" rel="external">@arvinh</a> 前端攻城獅，熱愛數據分析和資訊視覺化</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[人人都會的 Android Apk 反編譯]]></title>
      <url>http://blog.techbridge.cc/2016/03/24/android-decompile-introduction/</url>
      <content type="html"><![CDATA[<p>對於 Android 工程師來說，了解如何反編譯可以增進自己對 Android 底層的理解，也可以思考如何保護自己的 apk 不被反編譯。</p>
<p>對於一般人來說，許多現成的工具可以幫助我們非常輕鬆的、只要打打幾個指令就可以反編譯 apk，看到 java source code，滿足自己的好奇心。</p>
<p>本篇文章只介紹一些工具的使用，適合初學者觀看。若是想了解更底層的知識，可以參考文末附上的延伸閱讀。</p>
<h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>首先，我們需要一個用來被破解的 apk，簡單用任何你平常熟悉的工具自己 build 一個就好了。基本架構很簡單，只要一個 <code>MainActivity</code> 跟兩個<code>TextView</code>就好：</p>
<figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView text = (TextView)findViewById(R.id.text);</span><br><span class="line">        text.setText(<span class="string">"Taiwan No1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><figcaption><span>activity_main.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>安裝到手機上之後，會看到這樣的畫面：</p>
<p><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/uVN5gnA0QC6PEdujMIZg_device-2016-03-20-152510.png" alt="device-2016-03-20-152510.png"></p>
<h2 id="實際動手"><a href="#實際動手" class="headerlink" title="實際動手"></a>實際動手</h2><p>好，這個就是我們要拿來測試的 apk 了！<br>接著你需要一些非常好用的工具：</p>
<ol>
<li><a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">apktool</a></li>
<li><a href="http://jd.benow.ca/" target="_blank" rel="external">jd-gui</a></li>
<li><a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="external">dex2jar</a></li>
</ol>
<p>如何安裝就不再贅述了，讀者們可以參考看看文件或是上網搜尋一下就會有一堆解答～<br><code>apktool</code>是拿來把 apk 拆開用的，可以反編譯 apk 之後，看到 <code>smali</code> 檔案跟 <code>resource</code><br><code>dex2jar</code>可以把 apk 轉成 jar，再用<code>jd-gui</code>檢視 java code</p>
<p>接著我們開啟 terminal，到剛剛那個示範 apk 的目錄底下，執行<code>apktool d APKNAME.apk</code><br><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/Ahk6ZkFOQm7ECISEyxMI_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-20%20%E4%B8%8B%E5%8D%883.32.47.png" alt="螢幕快照 2016-03-20 下午3.32.47.png"></p>
<p>執行以後，會自動生成一個<code>APKNAME</code>的資料夾，裡面就是反編譯出來的東西了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── AndroidManifest.xml</span><br><span class="line">├── apktool.yml</span><br><span class="line">├── original</span><br><span class="line">├── res</span><br><span class="line">└── smali</span><br></pre></td></tr></table></figure>
<p>其中比較值得講的是<code>smali</code>這個資料夾，其實這裡面就是你的 source code，只是格式不太一樣。<br>你可以在<code>smali</code>這資料夾裡面找到你的<code>MainActivity.java</code>，內容如下：<br>（覺得長得很奇怪是很正常的事，但是認真多看幾眼，你會發現其實沒那麼難懂）</p>
<figure class="highlight"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.class public Lapktest/huli/com/apkdecompile/MainActivity;</span><br><span class="line">.super Landroid/app/Activity;</span><br><span class="line">.source "MainActivity.java"</span><br><span class="line"></span><br><span class="line"># direct methods</span><br><span class="line">.method public constructor &lt;init&gt;()V</span><br><span class="line">    .locals 0</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 8</span><br><span class="line">    invoke-direct &#123;p0&#125;, Landroid/app/Activity;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"># virtual methods</span><br><span class="line">.method protected onCreate(Landroid/os/Bundle;)V</span><br><span class="line">    .locals 2</span><br><span class="line">    .param p1, "savedInstanceState"    # Landroid/os/Bundle;</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 12</span><br><span class="line">    invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">    .line 13</span><br><span class="line">    const v1, 0x7f040019</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V</span><br><span class="line"></span><br><span class="line">    .line 14</span><br><span class="line">    const v1, 0x7f0c0050</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;findViewById(I)Landroid/view/View;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    check-cast v0, Landroid/widget/TextView;</span><br><span class="line"></span><br><span class="line">    .line 15</span><br><span class="line">    .local v0, "text":Landroid/widget/TextView;</span><br><span class="line">    const-string v1, "Taiwan No1"</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V</span><br><span class="line"></span><br><span class="line">    .line 16</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>你可以仔細對照一下剛剛自己寫的 java code，會發現只是換了種格式而已：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_main);</span><br></pre></td></tr></table></figure>
<p>其實就等於</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.line <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> v1, <span class="number">0x7f040019</span></span><br><span class="line">invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V</span><br></pre></td></tr></table></figure>
<p>你可能會好奇，這個<code>0x7f040019</code>是哪來的？<br>事實上，你可以在<code>res/values/public.xml</code>這個檔案裡面找到答案：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">public</span> <span class="attr">type</span>=<span class="string">"layout"</span> <span class="attr">name</span>=<span class="string">"activity_main"</span> <span class="attr">id</span>=<span class="string">"0x7f040019"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>到這裡，應該就可以大概猜出 Android 在編譯時候的流程：</p>
<ol>
<li>把所有資源檔壓縮、處理並且包在一起，產生<code>id與記憶體位置對照表</code></li>
<li>把程式碼裡面所有的<code>R.xx.xxx</code>透過剛剛產生的表，換成實際的記憶體位置</li>
<li>把 java code 變成 smali code（有點像把 C 變成組合語言的程式碼那樣）</li>
</ol>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>在剛剛的<code>smali</code>裡面，有這麼一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.line <span class="number">15</span></span><br><span class="line">.local v0, <span class="string">"text"</span>:Landroid/widget/TextView;</span><br><span class="line"><span class="keyword">const</span>-string v1, <span class="string">"Taiwan No1"</span></span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V</span><br></pre></td></tr></table></figure>
<p>讓我們把<code>Taiwan No1</code>換成<code>T@iw@n n0!</code>。<br>還記得另一個<code>TextView</code>有用到<code>R.string.hello_world</code>嗎？<br>在<code>res/values/strings.xml</code>裡面，可以找到這一串的定義：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>確定都有改完以後，就可以把這些程式碼再度「組裝」回去。<br>還記得剛剛反編譯的指令嗎？<code>apktool d APK_NAME.apk</code><br>這邊的<code>d</code>就是<code>decompile</code>的意思，所以如果要逆向組裝回去，就是<code>b</code>，<code>build</code>。</p>
<p><code>apktool b APK_NAME</code></p>
<p>執行完之後可以在<code>APK_NAME/dist</code>下面找到一個 apk。<br>但要注意的是這個 apk 還沒有被 sign 過，因此無法安裝。<br>可以隨便生成一個 keystore 或是找現成的來簽署。<br><code>jarsigner -verbose -digestalg SHA1 -keystore ~/KEY.keystore APK_NAME.apk KEY_ALIAS</code></p>
<p>安裝完以後就會看到這樣的畫面：</p>
<p><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/RNKaPElHQA2BJ02proFr_device-2016-03-20-160501.png" alt="device-2016-03-20-160501.png"></p>
<p>沒錯！就是這麼簡單，一個 apk 就這樣被修改了！</p>
<p>可是<code>smali</code>的程式碼不好懂，能不能直接看到 java code呢？<br>這時候剛剛推薦的工具<code>dex2jar</code>與<code>jd-gui</code>就派上用場了<br>前者可以把 apk 變成 jar，後者可以開啟一個 jar 並且顯示 java code<br>兩個組合在一起，就可以直接看到原本的程式碼了</p>
<p><code>dex2jar</code>下載下來之後會有一堆的 shell script，<code>dex2jar</code>就是我們想要的那個<br><code>./d2j-dex2jar.sh app.apk</code><br>執行完之後會有一個 jar，用 jd-gui 打開，會看到你的程式碼一覽無遺：</p>
<p><img src="http://user-image.logdown.io/user/7013/blog/6977/post/661513/zrnTKCQgT0OeIPbkkfp8_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-20%20%E4%B8%8B%E5%8D%884.10.15.png" alt="螢幕快照 2016-03-20 下午4.10.15.png"></p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>沒接觸過反編譯的人可能會很驚訝：什麼！要改掉一個 apk 居然這麼簡單！<br>沒錯，就是這麼簡單，而且這只是一個很基本的範例而已。事實上，你想要加入新的程式碼、加入新的資源（圖片、聲音等等）也是可以的。<br>也就是說，你不只可以修改，還可以擴充原本的 apk！</p>
<p>但也有些方法可以防止不肖人士反編譯 apk，例如說加殼、混淆、動態載入等，關於這些方法我們下次有機會再介紹給大家囉！</p>
<h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ol>
<li><a href="https://magiclen.org/android-decompiler/" target="_blank" rel="external">Android 反編譯與防止被反編譯</a></li>
<li><a href="http://aiur3908.blogspot.tw/2015/07/android-proguard.html" target="_blank" rel="external">[Android] 程式碼混淆(ProGuard)與反組譯</a></li>
<li><a href="http://blog.davidou.org/archives/553" target="_blank" rel="external">[Android] 反組譯 破解Android的apk安裝檔</a></li>
<li><a href="http://www.wangchenlong.org/2016/03/19/reverse-analyze-apk/" target="_blank" rel="external">反编译的常用工具与使用方法</a></li>
<li><a href="http://blog.csdn.net/wdaming1986/article/details/8299996" target="_blank" rel="external">Smali–Dalvik虚拟机指令语言–&gt;【android_smali语法学习一】</a></li>
<li><a href="http://blog.isming.me/2015/01/14/android-decompile-smali/" target="_blank" rel="external">android反编译-smali语法</a></li>
</ol>
<p>關於作者：<br><a href="http://huli.logdown.com/" target="_blank" rel="external">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Caffe & GoogLeNet，怎麼幫助機器人更好地辨識物體]]></title>
      <url>http://blog.techbridge.cc/2016/03/19/ros-caffe/</url>
      <content type="html"><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>這次要談的內容，是使用深度學習(Deep Learing)的模型來讓機器人做物體辨識。深度學習在這幾年來變得很火紅，相關的框架也相當多，這次之所以想談caffe，是因為已經有現成的方法可以將它應用到機器人上面。（有位台灣的開發者弄了一個叫做<a href="https://github.com/tzutalin/ros_caffe" target="_blank" rel="external">ros_caffe</a>的package來串接ROS(機器人作業系統)跟Caffe，可以將Caffe辨識的結果丟到一個ROS的topic，其他的node就可以自己取用。這使得機器人辨識物體的能力得以大幅增加）</p>
<h2 id="一點點幫助入門的細節"><a href="#一點點幫助入門的細節" class="headerlink" title="一點點幫助入門的細節"></a>一點點幫助入門的細節</h2><p>基本的安裝方法可以參考<a href="http://tzutalin.blogspot.tw/2015/06/setup-caffe.html" target="_blank" rel="external">這個連結</a>，假設已經裝成功，那至少就已經有基本的環境可以用(有一個caffe的資料夾被放在你安裝的路徑)，接下來需要下載<a href="https://github.com/BVLC/caffe/tree/master/models/bvlc_googlenet" target="_blank" rel="external">GoogLeNet的model</a>，只要用caffe/scripts資料夾裡的程式幫忙就行了:</p>
<p><code>$./scripts/download_model_binary.py ./models/bvlc_googlenet</code></p>
<p>上面這個指令會將GoogLeNet的model下載到caffe/models/bvlc_googlenet，假設已經下載好model，接下來就可以用一個小程式來跑跑看GoogLeNet了:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> 	</span><br><span class="line"><span class="comment"># Make sure that caffe is on the python path:</span></span><br><span class="line">caffe_root = <span class="string">'../'</span> <span class="comment"># this file is expected to be in &#123;caffe_root&#125;/examples</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, caffe_root + <span class="string">'python'</span>)</span><br><span class="line">sys.path.append(&amp;quot;/usr/lib/python2<span class="number">.7</span>/dist-packages/&amp;quot;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the right path to your model definition file, pretrained model weights,</span></span><br><span class="line"><span class="comment"># and the image you would like to classify.</span></span><br><span class="line">MODEL_FILE = <span class="string">'../models/bvlc_googlenet/deploy.prototxt'</span></span><br><span class="line">PRETRAINED = <span class="string">'../models/bvlc_googlenet/bvlc_googlenet.caffemodel'</span></span><br><span class="line">IMAGE_FILE = <span class="string">'images/cat.jpg'</span></span><br><span class="line"> </span><br><span class="line">caffe.set_mode_cpu()</span><br><span class="line">net = caffe.Classifier(MODEL_FILE, PRETRAINED,</span><br><span class="line">mean=np.load(caffe_root + <span class="string">'python/caffe/imagenet/ilsvrc_2012_mean.npy'</span>).mean(<span class="number">1</span>).mean(<span class="number">1</span>),</span><br><span class="line">channel_swap=(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">raw_scale=<span class="number">255</span>,</span><br><span class="line">image_dims=(<span class="number">256</span>, <span class="number">256</span>))</span><br><span class="line"> </span><br><span class="line">input_image = caffe.io.load_image(IMAGE_FILE)</span><br><span class="line">plt.imshow(input_image)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line">prediction = net.predict([input_image])</span><br><span class="line">plt.plot(prediction[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'predicted class:'</span>, prediction[<span class="number">0</span>].argmax()</span><br></pre></td></tr></table></figure>
<p>接下來只要執行(因為程式放在examples資料夾底下):</p>
<p><code>$python ./examples/googlenet_example.py</code></p>
<p>就可以看到一隻貓的影像，關掉影像之後就會看到貓的類別:</p>
<p><img src="/img/pojenlai/cat_class.png" alt="cat_class"></p>
<h2 id="串接ros-caffe"><a href="#串接ros-caffe" class="headerlink" title="串接ros_caffe"></a>串接ros_caffe</h2><p>如果想往下跟ros_caffe的串接可以參考<a href="http://www.artificialhumancompanions.com/integrating-ros-caffe-opencv-on-the-autonomous-deep-learning-robot/" target="_blank" rel="external">外國鄉民的文章</a>，裡面有完整而詳細的步驟。如果你已經安裝過caffe，可以參考<a href="https://github.com/tzutalin/ros_caffe/issues/1" target="_blank" rel="external">這個issue</a>。</p>
<p>需要注意的是，外國鄉民跑的只有global的結果，也就是一張影像中只有一個最顯著的物體會被辨識，如果要辨識一張影像中的各個物體，可能就要自己在中間串接一個負責做segmentation的node，再把各個切出來的區塊餵給ros_caffe來做辨識。</p>
<p>關於作者：<br><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何打造更好的科技新創 (Startup) 工作環境和組織文化？]]></title>
      <url>http://blog.techbridge.cc/2016/03/19/how-to-build-a-great-startup-culture/</url>
      <content type="html"><![CDATA[<p>最近剛好在<a href="http://www.zhihu.com/" target="_blank" rel="external">知乎</a>上看到一篇<a href="http://daily.zhihu.com/story/4264615" target="_blank" rel="external">矽谷新創公司文化和工作環境的文章</a> (內容主要還是以網路或科技新創公司為主)。這些公司雖然業務內容大不相同但還是有一些共通性。根據自己的經驗做一下翻譯和補充，期待未來台灣也能有更多世界一流的科技新創公司，提供人才更好的舞台和工作環境，大家一起加油啦！</p>
<p>第 0 步：找到對的人上車 (確保每位加入成員都能理解並認同公司價值觀和願景。打造優良的組織文化並不容易，但崩解可能只是一夕之間。最初 Airbnb 找第一號員工就花了約半年的時間！)</p>
<p>參考文件：<a href="http://36kr.com/p/216739.html" target="_blank" rel="external">Airbnb創辦人Brian Chesky談企業文化</a></p>
<ol>
<li>開放式辦公室，直接溝通，少開會。代碼勝於雄辯 (Code wins arguments.)</li>
<li>免費食物，提供工作餐點，也可以說故意延長工作時間 :P</li>
<li>使用蘋果電腦 (Mac) 或 Linux， 以及使用 Linux 的雲端伺服器 (Cloud Server)</li>
<li>擁抱開源軟體 (Open Source)，利用各種可用工具，注意力集中在核心產品</li>
<li>快速迭代 (Iterate)，A / B Testing，數據驅動思考 (Data Driven Thinking)</li>
<li>注重使用者體驗 (User Experience)，使用者利益大於獲利考慮</li>
<li>簡約設計，注重 MVP (最小可行) 的產品，敏捷開發</li>
<li>工程師文化，不惜代價找到最合適的人才，常舉辦內部 Hack Day。技術分享風氣濃厚，熱於學習新技術</li>
</ol>
<p>事實上，以上幾點科技新創 (Startup) 的常見文化和工作環境未必合適於每個組織中。能找到合適的夥伴加入團隊，一起打造適合的文化和價值觀才是關鍵。</p>
<p>參考文件：</p>
<ol>
<li><a href="http://blog.littlelin.info/posts/2014/05/04/what-makes-good-engineering-culture-1" target="_blank" rel="external">[翻譯] 是什麼造就了好的軟體工程文化？(上)</a></li>
<li><a href="http://blog.littlelin.info/posts/2014/09/21/what-makes-good-engineering-culture-2" target="_blank" rel="external">[翻譯] 是什麼造就了好的軟體工程文化？(下)</a></li>
</ol>
<p>關於作者：<br><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校，目前專注在 Mobiel 和 IoT 應用開發。A Starter &amp; Maker. JavaScript, Python &amp; iOS/Android lover. Keep Shipping Cool Mobile App &amp; Web App.:)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[關於這個技術共筆部落格]]></title>
      <url>http://blog.techbridge.cc/2016/03/19/about/</url>
      <content type="html"><![CDATA[<p>TechBridge Weekly 技術週刊團隊是一群對用技術改變世界懷抱熱情的團隊。本技術共筆部落格初期專注於Web前後端、行動網路、機器人/物聯網、數據分析與產品設計等正體中文技術或國外好文翻譯分享。This is TechBridge Weekly Team Tech Blog, which focus on web, mobile, robot, IoT, data analytics technology sharing.</p>
<ul>
<li>技術日報：<a href="http://www.techbridge.cc/" target="_blank" rel="external">http://www.techbridge.cc/</a></li>
<li>技術週刊：<a href="http://weekly.techbridge.cc/" target="_blank" rel="external">http://weekly.techbridge.cc/</a></li>
<li>技術共筆部落格：<a href="http://blog.techbridge.cc/">http://blog.techbridge.cc/</a></li>
<li>粉絲專頁：<a href="https://www.facebook.com/TechBridge.Fans/" target="_blank" rel="external">https://www.facebook.com/TechBridge.Fans/</a></li>
<li>電子郵件：<a href="mailto:techbridge.cc@gmail.com" target="_blank" rel="external">techbridge.cc@gmail.com</a></li>
</ul>
<h2 id="目前負責的-Curator（歡迎有興趣朋友跳坑加入策展人團隊-P）"><a href="#目前負責的-Curator（歡迎有興趣朋友跳坑加入策展人團隊-P）" class="headerlink" title="目前負責的 Curator（歡迎有興趣朋友跳坑加入策展人團隊:P）"></a>目前負責的 Curator（歡迎有興趣朋友跳坑加入策展人團隊:P）</h2><ol>
<li><a href="http://blog.kdchang.cc" target="_blank" rel="external">@kdchang</a> 文藝型開發者，夢想是做出人們想用的產品和辦一所心目中理想的學校</li>
<li><a href="http://cv.arvinh.info" target="_blank" rel="external">@arvinh</a> 前端攻城獅，熱愛數據分析和資訊視覺化</li>
<li><a href="http://huli.logdown.com" target="_blank" rel="external">@huli</a> 野生工程師，相信分享與交流能讓世界變得更美好</li>
<li><a href="https://pojenlai.wordpress.com/" target="_blank" rel="external">@pojenlai</a> 演算法工程師，對機器人跟電腦視覺有少許研究，最近在鍛鍊自己的執行力</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
